#Analyze pathways through the network of tallies
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
#TODO:
#X- Track if path consists of only inside, user members
#X- Properly handle peers that are not our users (we only have a stock or foil type tally)
#X- Pull minimum lift size from system parameters
#- Only process lifts that have a cost factor 1 or better
#- Allow reverse lifts by examining foil tallies with reverse margins enabled
#- Also honor minimum lift sizes from user settings, or the tallies themselves
#- Raise up any negative costs in the lift to achieve a 1 factor
#- Honor all tally lift variables properly
#-   bal_target
#-   lift_marg
#-   drop_marg
#-   dr_limit
#-   cr_limit
#- Ignore tallies that are not in current status
#- 
#- Show peers that are on different servers reasonably in the path view
#- How to query for off-site lifts?
#- 
#- 
module mychips

other uuid {} {create extension "uuid-ossp"} {drop extension if exists "uuid-ossp"}
#other pgcrypto {} {create extension "pgcrypto"} {drop extension if exists "pgcrypto"}

# Stores info about external pathways discovered from foreign servers
#----------------------------------------------------------------
table mychips.routes {mychips.peers} {
    route_ent	text		not null references mychips.peers on update cascade on delete cascade
  , peer_ent	text		references mychips.peers on update cascade on delete cascade
  , peer_hid	text
  , peer_host	text		check ((peer_ent is not null and peer_hid is null and peer_host is null) or (peer_ent is null and peer_hid is not null and peer_host is not null))
  , requ_ent	text		references mychips.peers on update cascade on delete cascade
  , status	text		not null default 'void'
  , tries	int		not null default 0
  , used	int		not null default 0
  , used_date	timestamptz	not null default current_timestamp
  , find_date	timestamptz	not null default current_timestamp
  , exp_date	timestamptz	not null default current_timestamp + '24 hours'::interval
  , primary key (stock_ent, foil_ent)
}
#index {} mychips.paths used_date

# Recursive view of tallies to show pathways native to our system
#----------------------------------------------------------------
view mychips.tallies_v_paths {mychips.users_v mychips.tallies_v_net mychips.lift_max(bigint,bigint,bigint,bigint)} {
  with recursive tally_path(first, last, length, path, guids, cycle, circuit, cost, min, max, inside, fora, forz) as (
    select	p.peer_ent, p.peer_ent, 1, array[p.peer_ent], '{}'::uuid[], false, false, 1.00::float, null::bigint, null::bigint, not p.user_ent isnull, p.user_ent isnull, p.user_ent isnull
    from	mychips.users_v p
    where	not p.peer_ent isnull
  union all
    select tp.first					as first
      , t.stock_ent					as last
      , tp.length + 1					as length
      , tp.path || t.stock_ent				as path
      , tp.guids || t.guid				as guids
      , t.stock_ent = any(tp.path)			as cycle
      , tp.path[1] = t.stock_ent			as circuit
      , tp.cost * (1 + t.margin)			as cost
      , least(tp.min, mychips.lift_max(
          t.units, t.target, t.cr_max, t.dr_max
        ))						as min
--      , coalesce(least(t.units,tp.min), t.units)	as min
      , coalesce(greatest(t.units,tp.max), t.units)	as max
      , tp.inside and not t.stock_user isnull		as inside
      , t.stock_user isnull				as fora
      , not tp.inside					as forz
    from	mychips.tallies_v_net t
    join	tally_path	tp on tp.last = t.foil_ent and not tp.cycle
  ) select tpr.first, tpr.last
    , tpr.length, tpr.path, tpr.guids
    , tpr.circuit, tpr.cost, tpr.min, tpr.max
    , tpr.length * tpr.min as bang
    , tpr.inside , tpr.fora , tpr.forz
  from tally_path tpr 
} -primary {last first length}

# Simplified view for discovering lifts
#----------------------------------------------------------------
view mychips.tallies_v_lifts {mychips.tallies_v_paths} {
  select bang,length,min,max,path from mychips.tallies_v_paths where circuit order by 1 desc
}

# Generate a maximum lift amount for a given tally set
#----------------------------------------------------------------
function {mychips.lift_max(units bigint, target bigint, crmax bigint, drmax bigint)} {mychips} {
  returns bigint language plpgsql immutable as $$
    declare
--Fixme: consider/honor credit/debit limits here
    begin
      return greatest(units, units-target);
    end;
$$;}

# Generate a set of chits for a lift involving the specified tallies, all our own users
#----------------------------------------------------------------
function {mychips.internal_lift(units bigint, uupath uuid[])} {mychips.tallies mychips.chits uuid} {
  returns boolean language plpgsql security definer as $$
    declare
      tally_id	uuid;
      lift_id	uuid;
      trec	record;
      tcount	int;
    begin
      lift_id = uuid_generate_v1();
--raise notice 'Lift :% %', units, uupath;
      foreach tally_id in array uupath loop
        tcount = 0;
        for trec in select * from mychips.tallies where tally_guid = tally_id order by tally_type loop
          insert into mychips.chits (chit_ent, chit_seq, chit_guid, chit_type, signature, units) values (trec.tally_ent, trec.tally_seq, lift_id, 'lift', 'Valid', -units);
          tcount = tcount + 1;
        end loop;
        if tcount != 2 then
          raise exception 'Could not find exactly two tallies for UUID:%', tally_id;
          return false;
        end if;
      end loop;
      return true;
    end;
$$;}

# Query the database for possible lifts, initiating one or more if needed
#----------------------------------------------------------------
function {mychips.lift_cycle(maxNum int default 1)} {mychips.tallies_v_paths base.parm_v} {
  returns jsonb language plpgsql security definer as $$
    declare
      status	jsonb = '{"done": 0}';
      prec	record;			-- Paths
      orders	text default 'bang desc';
      tstr	text;
      tarr	text[];
      oarr	text[];
      lift_id	uuid;
      min_units	int default base.parm('lifts','minimum');	-- Only do lifts of this size or bigger
      count	int default 0;
      rows	int;
    begin
      select into prec * from base.parm_v where module = 'lifts' and parm = 'order';
      if found then				-- Build a custom order-by clause
        foreach tstr in array regexp_split_to_array(prec.value, ',') loop
          oarr = regexp_split_to_array(btrim(tstr), E'\\s+');
--raise notice 'LC1 tstr:% el0:%', tstr, oarr[1];
          tarr = array_append(tarr, quote_ident(oarr[1]) || case when oarr[2] = 'desc' then ' desc' else '' end);
        end loop;
        orders = array_to_string(tarr, ', ');
      end if;

-- These are all internal lifts for now (circuit)      
      while count < maxNum loop
        tstr = 'select length, min, max, cost, path, guids from mychips.tallies_v_paths where circuit and min >= $1 order by ' || orders || ' limit 1';
--raise notice 'LC2 min:% max:% ord:% sql:%', min_units, maxNum, orders, tstr;
        execute tstr into prec using min_units;			-- Look for the highest priority lift to execute
        get diagnostics rows = ROW_COUNT;
--raise notice 'LC3 :% % % %', prec.length, prec.min, prec.max, rows;
        if rows < 1 then exit; end if;
        if not mychips.internal_lift(prec.min, prec.guids) then exit; end if;
        count = count + 1;
      end loop;
    return jsonb_set(status, '{done}', count::text::jsonb);
    end;
$$;}
