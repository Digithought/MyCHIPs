#Views to parse locally held tallies into traversable lift pathways
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------

# View showing a single entry for each credit relationship (for lift algorithm, pathway views)
#----------------------------------------------------------------
view mychips.tallies_v_net {mychips.tallies} {select 
    coalesce(ts.tally_uuid,tf.tally_uuid)	as uuid
  , coalesce(ts.tally_ent,tf.part_ent)		as stock_ent
  , coalesce(tf.tally_ent,ts.part_ent)		as foil_ent
  , ts.tally_ent				as stock_user
--  , tf.tally_ent				as foil_user
  
  , tf.target							as lift_target
  , coalesce(tf.reward,0)					as lift_reward
  , coalesce(ts.clutch,0)					as lift_margin
  , tf.units_pc - least(-tf.target, 0)				as lift_min
  , tf.units_pc - least(-tf.bound, -tf.target, tf.dr_limit)	as lift_max
  
  , ts.target							as drop_target
  , coalesce(ts.reward,0)					as drop_reward
  , coalesce(tf.clutch,0)					as drop_margin
  , greatest(ts.target, 0) - ts.units_pc			as drop_min
  , greatest(ts.bound, ts.target, ts.cr_limit) - ts.units_pc	as drop_max
  
  from			(select * from mychips.tallies where tally_type = 'stock') ts
  full outer join	(select * from mychips.tallies where tally_type = 'foil') tf on tf.tally_uuid = ts.tally_uuid
}

# Recursive view of tallies to show pathways native to our system
#----------------------------------------------------------------
view mychips.tallies_v_paths {mychips.users_v mychips.tallies_v_net} {
  with recursive tally_path(first, last, length, path, uuids, cycle, circuit, inside, corein, fora, forz,
      lift_min, lift_margin, lift_max, lift_reward,
      drop_min, drop_margin, drop_max, drop_reward
    ) as (
    select	p.peer_ent, p.peer_ent, 1, array[p.peer_ent], '{}'::uuid[], false, false, not p.user_ent isnull, null::boolean, p.user_ent isnull, p.user_ent isnull,
      x'7FFFFFFFFFFFFFF'::bigint, 0::float, x'FFFFFFFFFFFFFFFF'::bigint, 0::float, 
      x'7FFFFFFFFFFFFFF'::bigint, 0::float, x'FFFFFFFFFFFFFFFF'::bigint, 0::float
    from	mychips.users_v p
    where	not p.peer_ent isnull
  union all
    select tp.first					as first
      , t.stock_ent					as last
      , tp.length + 1					as length
      , tp.path || t.stock_ent				as path
      , tp.uuids || t.uuid				as uuids
      , t.stock_ent = any(tp.path)			as cycle
      , tp.path[1] = t.stock_ent			as circuit
      , tp.inside and not t.stock_user isnull		as inside
      , case when tp.length < 2 then not t.stock_user isnull
        when tp.length = 2 then not tp.forz
        else tp.corein and not tp.forz
        end						as corein
      , tp.fora						as fora
      , t.stock_user isnull				as forz

      , least(t.lift_min,tp.lift_min)				as lift_min
      , tp.lift_margin + t.lift_margin * (1 - tp.lift_margin)	as lift_margin
      , case when t.lift_min < tp.lift_min then
          least(t.lift_max,tp.lift_min)
        else
          least(tp.lift_max,t.lift_min) end			as lift_max
      , case when t.lift_min < tp.lift_min then t.lift_reward else tp.lift_reward end as lift_reward

      , least(t.drop_min,tp.drop_min)				as drop_min
      , tp.drop_margin + t.drop_margin * (1 - tp.drop_margin)	as drop_margin
      , case when t.drop_min < tp.drop_min then
          least(t.drop_max,tp.drop_min)
        else
          least(tp.drop_max,t.drop_min) end			as drop_max
      , case when t.drop_min < tp.drop_min then t.drop_reward else tp.drop_reward end as drop_reward

    from	mychips.tallies_v_net t
    join	tally_path	tp on tp.last = t.foil_ent and not tp.cycle
  ) select tpr.first, tpr.last
    , tpr.length, tpr.path, tpr.uuids
    , tpr.circuit, tpr.inside, tpr.corein, tpr.fora, tpr.forz
    , tpr.lift_margin, tpr.lift_reward, tpr.drop_margin, tpr.drop_reward
    , greatest(tpr.lift_min, 0) as lift_min, greatest(tpr.lift_max, 0) as lift_max	-- Don't generate negative lift/drop allowances
    , greatest(tpr.drop_min, 0) as drop_min, greatest(tpr.drop_max, 0) as drop_max
--    , tpr.lift_min, tpr.lift_max, tpr.drop_min, tpr.drop_max
    , tpr.length * tpr.lift_min as bang
    , corein and fora and forz as segment
  from tally_path tpr where tpr.length > 1
} -primary {last first length}

# Simplified view for discovering inside lifts
#----------------------------------------------------------------
view mychips.tallies_v_lifts {mychips.tallies_v_paths} {
  select * from mychips.tallies_v_paths where circuit order by 1 desc
}

