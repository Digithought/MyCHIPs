#Analyze pathways through the network of tallies
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
# Routes indicate a possible lift pathway which exists outside our known set of
# tallies.  We will always obtain route data by querying adjacent peer servers.
# There are two kinds of route records:
# Native: This links two foreign peers, both known to our data set and also
#   linked by an internal pathway found in tallies_v_paths.  This implies, it
#   would complete a partial circuit we already know about.
# Relay: This is not for our own benefit but rather a result of a downstream
#   peer having asked us about it.  The route leads from one known foreign peer
#   to an unknown peer, hopefully to be found somewhere upstream.
# 
#TODO:
#X- Track if path consists of only inside, user members
#X- Properly handle peers that are not our users (we only have a stock or foil type tally)
#X- Pull minimum lift size from system parameters
#- Test/debug route query retries
#- 
#- Only process lifts that have a cost factor 1 or better
#- Allow reverse lifts by examining foil tallies with reverse margins enabled
#- Also honor minimum lift sizes from user settings, or the tallies themselves
#- Raise up any negative costs in the lift to achieve a 1 factor
#- Honor all tally lift variables properly
#-   bal_target
#-   lift_marg
#-   drop_marg
#-   dr_limit
#-   cr_limit
#- Ignore tallies that are not in current status
#- 
#- Show peers that are on different servers reasonably in the path view
#- How to query for off-site lifts?
#- Make indexed, materialized cache of tallies_v_paths that is incrementally updated via triggers
#- 

namespace eval paths {
    def routes_pk	{route_ent dest_chid dest_host}
#    def routes_v_up	{request comment cr_limit dr_limit}
#    def routes_v_in	[concat tally_ent $tallies_v_up tally_guid tally_type version partner contract user_sig]
    def routes_se	[concat $routes_pk dest_ent topu_ent botu_ent requ_ent status lift_count lift_date good_date]
}

module mychips

other uuid {} {create extension "uuid-ossp"} {drop extension if exists "uuid-ossp"}
#other pgcrypto {} {create extension "pgcrypto"} {drop extension if exists "pgcrypto"}

# Stores info about external pathways discovered from foreign servers
#----------------------------------------------------------------
table mychips.routes {mychips.peers} {
    route_ent	text		not null references mychips.peers on update cascade on delete cascade
  , dest_chid	text
  , dest_host	text		--?? check ((dest_ent is not null and dest_host isnull) or (dest_ent isnull and dest_host is not null))
  , dest_ent	text		references mychips.peers on update cascade on delete cascade
  , topu_ent	text		not null references mychips.peers on update cascade on delete cascade
  , botu_ent	text		not null references mychips.peers on update cascade on delete cascade
  , requ_ent	text		not null references mychips.peers on update cascade on delete cascade
  , status	text		not null default 'draft'
  , lift_count	int		not null default 0
  , lift_date	timestamptz	not null default current_timestamp
  , good_date	timestamptz	not null default current_timestamp
  , primary key(route_ent, dest_chid, dest_host)
}
#index {} mychips.paths used_date

table mychips.route_tries {mychips.routes} {
    rtry_ent	text	      , primary key (rtry_ent, rtry_chid, rtry_host)
  , rtry_chid	text
  , rtry_host	text	      , foreign key (rtry_ent, rtry_chid, rtry_host) references mychips.routes on update cascade on delete cascade
  , tries	int		not null default 1
  , last	timestamptz	not null default current_timestamp
}

# Recursive view of tallies to show pathways native to our system
#----------------------------------------------------------------
view mychips.tallies_v_paths {mychips.users_v mychips.tallies_v_net mychips.lift_max(bigint,bigint,bigint,bigint)} {
  with recursive tally_path(first, last, length, path, guids, cycle, circuit, cost, min, max, inside, corein, fora, forz) as (
    select	p.peer_ent, p.peer_ent, 1, array[p.peer_ent], '{}'::uuid[], false, false, 1.00::float, null::bigint, null::bigint, not p.user_ent isnull, null::boolean, p.user_ent isnull, p.user_ent isnull
    from	mychips.users_v p
    where	not p.peer_ent isnull
  union all
    select tp.first					as first
      , t.stock_ent					as last
      , tp.length + 1					as length
      , tp.path || t.stock_ent				as path
      , tp.guids || t.guid				as guids
      , t.stock_ent = any(tp.path)			as cycle
      , tp.path[1] = t.stock_ent			as circuit
      , tp.cost * (1 + t.margin)			as cost
      , least(tp.min, mychips.lift_max(
          t.units, t.target, t.cr_max, t.dr_max
        ))						as min
      , coalesce(greatest(t.units,tp.max), t.units)	as max
      , tp.inside and not t.stock_user isnull		as inside
      , case when tp.length < 2 then not t.stock_user isnull
        when tp.length = 2 then not tp.forz
        else tp.corein and not tp.forz
        end						as corein
      , tp.fora						as fora
      , t.stock_user isnull				as forz
    from	mychips.tallies_v_net t
    join	tally_path	tp on tp.last = t.foil_ent and not tp.cycle
  ) select tpr.first, tpr.last
    , tpr.length, tpr.path, tpr.guids
    , tpr.circuit, tpr.cost, tpr.min, tpr.max
    , tpr.length * tpr.min as bang
    , tpr.inside, tpr.corein, tpr.fora, tpr.forz
  from tally_path tpr where tpr.length > 1
} -primary {last first length}

# Simplified view for discovering inside lifts
#----------------------------------------------------------------
view mychips.tallies_v_lifts {mychips.tallies_v_paths} {
  select bang,length,min,max,path from mychips.tallies_v_paths where circuit order by 1 desc
}

# View showing join of inside pathways and outside routes
# to discover/analyze possible distributed lifts
#----------------------------------------------------------------
view mychips.routes_v_lifts {mychips.tallies_v_paths mychips.routes_v} {select
    tp.first
  , tp.last
  , tp.length
  , tp.path
  , tp.corein
  , r.state
  , r.dest_ent		--Fixme update with latest available fields
  , r.dest_chid
  , r.dest_host
  , r.dest_addr
  , r.lift_count
  
  from		mychips.tallies_v_paths	tp
  join	mychips.routes_v	r on r.route_ent = tp.first and r.dest_ent = tp.last
  where tp.corein and r.native and tp.fora and tp.forz;
}

# Generate a maximum lift amount for a given tally set
#----------------------------------------------------------------
function {mychips.lift_max(units bigint, target bigint, crmax bigint, drmax bigint)} {mychips} {
  returns bigint language plpgsql immutable as $$
    declare
--Fixme: consider/honor credit/debit limits here
    begin
      return greatest(units, units-target);
    end;
$$;}

# Generate a set of chits for a lift involving the specified tallies, all our own users
#----------------------------------------------------------------
function {mychips.internal_lift(units bigint, uupath uuid[])} {mychips.tallies mychips.chits uuid} {
  returns boolean language plpgsql security definer as $$
    declare
      tally_id	uuid;
      lift_id	uuid;
      trec	record;
      tcount	int;
    begin
      lift_id = uuid_generate_v1();
--raise notice 'Lift :% %', units, uupath;
      foreach tally_id in array uupath loop
        tcount = 0;
        for trec in select * from mychips.tallies where tally_guid = tally_id order by tally_type loop
          insert into mychips.chits (chit_ent, chit_seq, chit_guid, chit_type, signature, units) values (trec.tally_ent, trec.tally_seq, lift_id, 'lift', 'Valid', -units);
          tcount = tcount + 1;
        end loop;
        if tcount != 2 then
          raise exception 'Could not find exactly two tallies for UUID:%', tally_id;
          return false;
        end if;
      end loop;
      return true;
    end;
$$;}

# Query the database for possible internal lifts, initiating one or more if needed
#----------------------------------------------------------------
function {mychips.lift_cycle(maxNum int default 1)} {mychips.tallies_v_paths base.parm_v} {
  returns jsonb language plpgsql security definer as $$
    declare
      status	jsonb = '{"done": 0}';
      prec	record;			-- Paths
      orders	text default 'bang desc';
      tstr	text;
      tarr	text[];
      oarr	text[];
      lift_id	uuid;
      min_units	int default base.parm('lifts','minimum',1);	-- Only do lifts of this size or bigger
      count	int default 0;
      rows	int;
    begin
      select into prec * from base.parm_v where module = 'lifts' and parm = 'order';
      if found then				-- Build a custom order-by clause
        foreach tstr in array regexp_split_to_array(prec.value, ',') loop
          oarr = regexp_split_to_array(btrim(tstr), E'\\s+');
--raise notice 'LC1 tstr:% el0:%', tstr, oarr[1];
          tarr = array_append(tarr, quote_ident(oarr[1]) || case when oarr[2] = 'desc' then ' desc' else '' end);
        end loop;
        orders = array_to_string(tarr, ', ');
      end if;

-- These are all internal lifts for now (circuit)      
      while count < maxNum loop
        tstr = 'select length, min, max, cost, path, guids from mychips.tallies_v_paths where circuit and min >= $1 order by ' || orders || ' limit 1';
--raise notice 'LC2 min:% max:% ord:% sql:%', min_units, maxNum, orders, tstr;
        execute tstr into prec using min_units;			-- Look for the highest priority lift to execute
        get diagnostics rows = ROW_COUNT;
--raise notice 'LC3 :% % % %', prec.length, prec.min, prec.max, rows;
        if rows < 1 then exit; end if;
        if not mychips.internal_lift(prec.min, prec.guids) then exit; end if;
        count = count + 1;
      end loop;
    return jsonb_set(status, '{done}', count::text::jsonb);
    end;
$$;}

# Consistency check for new/updated routes
#----------------------------------------------------------------
function mychips.routes_tf_biu() {mychips.peers_v} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.dest_chid isnull then
          select into new.dest_chid, new.dest_host peer_cid, peer_chost from mychips.peers_v where peer_ent = new.dest_ent;
        end if;

-- These are mostly for simplicity in debugging when manually inserting test routes:
        if new.topu_ent isnull then new.topu_ent = new.requ_ent; end if;
        if new.botu_ent isnull then new.botu_ent = new.requ_ent; end if;
        return new;
    end;
$$;}
trigger mychips_routes_tr_biu {} {
    before insert or update on mychips.routes for each row execute procedure mychips.routes_tf_biu();
}

# Compute current state of a route, based on its various fields
#----------------------------------------------------------------
function {mychips.route_state(status text, expired boolean, trymax boolean)} {mychips} {
  returns text stable language plpgsql as $$
    begin
      return case when status = 'draft'				then 'draft'
         when status = 'none'					then 'none'
         when status = 'pend' then
           case when expired and not trymax			then 'timeout'
                when expired and trymax				then 'unknown'
           else 'pend' end
         when status = 'good' then
           case when expired					then 'stale'
           else 'good' end
         when status = 'none'					then 'none'
         else 'undefined' end;
    end;
$$;}

# Cache route lifetime interval
#----------------------------------------------------------------
function {mychips.route_life()} {mychips base.parm_v} {
  returns interval language plpgsql stable as $$
    begin
      return base.parm('routes', 'life', '1 week'::text)::interval;
    end;
$$;}

# Base view of pathway routes
#----------------------------------------------------------------
view mychips.routes_v {mychips.routes mychips.users_v mychips.peers_v mychips.route_state(text,boolean,boolean) base.parm_v mychips.route_life()} {select 
    eval(fld_list $paths::routes_se	ro)
  , re.peer_cid		as route_cid
  , re.peer_addr	as route_addr
  , re.peer_sock	as route_sock
  , re.peer_endp	as route_endp
  , re.std_name		as route_name

  , de.peer_cid		as dest_cid
  , de.peer_addr	as dest_addr
  , de.peer_sock	as dest_sock
  , de.peer_endp	as dest_endp
  , de.std_name		as dest_name

  , te.peer_cid		as topu_cid
  , te.peer_addr	as topu_addr
  , te.peer_sock	as topu_sock
  , te.peer_endp	as topu_endp
  , te.host_id		as topu_serv
  , te.std_name		as topu_name

  , be.peer_cid		as botu_cid
  , be.peer_addr	as botu_addr
  , be.peer_sock	as botu_sock
  , be.peer_endp	as botu_endp
  , be.std_name		as botu_name
  , be.host_id		as botu_serv

  , qe.peer_cid		as requ_cid
  , qe.peer_addr	as requ_addr
  , qe.peer_sock	as requ_sock
  , qe.peer_endp	as requ_endp
  , qe.std_name		as requ_name

  , not qe.user_ent isnull			as native
  , ro.dest_chid || '@' || ro.dest_host		as dest_chad
  , greatest(ro.good_date,ro.lift_date) + mychips.route_life()		as expires
  , rt.tries		as tries
  , rt.last		as last
  , mychips.route_state(status
    , current_timestamp > greatest(ro.good_date, ro.lift_date) + mychips.route_life()
    , coalesce(rt.tries,0) >= base.parm('routes','tries',4)
  )			as state
  , jsonb_build_object(				-- Packet we will transmit upstream
       'from'	,	re.peer_cid
     , 'fat'	,	re.peer_chost
     , 'to'	,	coalesce(de.peer_cid, ro.dest_chid)
     , 'tat'	,	coalesce(de.peer_host, ro.dest_host)
     , 'by'	,	te.peer_cid
     , 'bat'	,	te.peer_chost
     , 'port'	,	te.peer_cport
    )			as relay
  , jsonb_build_object(				-- Overlay for packet we transmit downstream
       'from'	,	be.peer_cid
     , 'fat'	,	be.peer_chost
     , 'to'	,	coalesce(de.peer_cid, ro.dest_chid)
     , 'tat'	,	coalesce(de.peer_host, ro.dest_host)
     , 'by'	,	qe.peer_cid
     , 'bat'	,	qe.peer_chost
     , 'port'	,	qe.peer_cport
    )			as reverse

    from	mychips.routes	ro
    join	mychips.peers_v	re on re.peer_ent = ro.route_ent	-- start of route
    join	mychips.users_v	te on te.peer_ent = ro.topu_ent		-- top local user in chain
    join	mychips.users_v	be on be.peer_ent = ro.botu_ent		-- bottom local user in chain
    join	mychips.users_v	qe on qe.peer_ent = ro.requ_ent		-- downstream foreign peer
    left join	mychips.users_v	de on de.peer_ent = ro.dest_ent		-- destination
    left join	mychips.route_tries rt on rt.rtry_ent = ro.route_ent and rt.rtry_chid = ro.dest_chid and rtry_host = ro.dest_host
}

# Notify the peer server process of route state changes, and next state request, that needs attention in the database
#----------------------------------------------------------------
function {mychips.route_notify(route mychips.routes)} {mychips.routes_v mychips.route_tries} {
  returns boolean language plpgsql security definer as $$
    declare
        act	text;
        jrec	jsonb;
        orec	record;			-- Route
        rrec	record;			-- Retries
        channel	text = 'mychips_peer';
    begin

        if route.status = 'draft' or route.status = 'good' or route.status = 'none' then		-- Determine next action
            act = route.status;
        end if;
--raise notice 'RN:% % % % %', act, route.route_ent, route.dest_ent, route.dest_chid, route.dest_host;
        if act isnull then return false; end if;			-- Must have a valid action

        select into orec route_ent,route_cid,route_addr,requ_sock,topu_sock,topu_serv,route_sock,dest_chid,dest_host,status,state,relay,reverse from mychips.routes_v where route_ent = route.route_ent and dest_chid = route.dest_chid;
        if not found then return false; end if;				-- Find the full-view route record

        if not orec.topu_serv isnull then
            channel = channel || '_' || orec.topu_serv;
        end if;

--Fixme: How are retries supposed to work (especially on good/none)?
        insert into mychips.route_tries (rtry_ent, rtry_chid, rtry_host) values (route.route_ent, route.dest_chid, route.dest_host)
          on conflict (rtry_ent,rtry_chid,rtry_host) do update set tries = mychips.route_tries.tries + 1, last = current_timestamp
            returning * into rrec;
--raise notice 'Rn c:% h:% p:% u:% s:%', channel, urec.host_id, prec.peer_cid, urec.peer_cid, prec.peer_sock;

        jrec = jsonb_build_object('target', 'route'
          , 'action'	, act
          , 'at'	, orec.route_sock
          , 'try'	, rrec.tries
          , 'step'	, 1
          , 'last'	, rrec.last
          , 'here'	, orec.topu_sock
          , 'back'	, orec.requ_sock
          , 'object'	, orec.relay
          , 'reverse'	, orec.reverse
        );
--raise notice '   notice:%', jrec::text;
        perform pg_notify(channel, jrec::text);			-- Notify peer server of next state action request
        return true;
    end;
$$;}

# Generate notifications about updated tallies for listening peer servers
#----------------------------------------------------------------
function mychips.routes_tf_notify() {mychips.route_notify(mychips.routes)} {
  returns trigger language plpgsql security definer as $$
    declare
        dirty	boolean default false;
    begin
        if TG_OP = 'INSERT' then
            dirty = true;
        elsif new.status != old.status then
            dirty = true;
        end if;
        if dirty then perform mychips.route_notify(new); end if;
        return new;
    end;
$$;}
trigger mychips_routes_tr_notice {} {
    after insert or update on mychips.routes for each row execute procedure mychips.routes_tf_notify();
}

# Process route state transitions requested by the peer server process
#----------------------------------------------------------------
function {mychips.route_process(msg jsonb, recipe jsonb)} {mychips.routes_v mychips.users_v} {
  returns text language plpgsql as $$
    declare
        obj		jsonb = msg->'object';
        from_r		record;		-- Search from this base (must exist)
        requ_r		record;		-- Which foreign peer requests this (must exist)
        dest_r		record;		-- Search to this destination (may exist)
        route_r		record;		-- Holds route record(s)
        qrec		record;		-- Temporary record
        trec		record;		-- Temporary record
        qstrg		text;		-- Temporary string
        curState	text;
        fwdcnt		int default 0;	-- Count how many queries forwarded
    begin
--raise notice 'Route from: % %; recipe: % obj: %', obj->>'from', obj->>'fat', recipe, obj;
        select into from_r id, host_id, peer_cid from mychips.users_v where peer_cid = obj->>'from' and peer_chost = obj->>'fat';	-- Look up the base entity
        if not found then return null; end if;

--raise notice ' by: % % %', obj->>'by', obj->>'bat', obj->>'port';
        select into requ_r id, peer_cid from mychips.users_v where peer_cid = obj->>'by' and peer_chost = obj->>'bat';	-- Look up the requesting entity
        if not found then return null; end if;

        select into dest_r id, user_ent, peer_cid, peer_chost from mychips.users_v where peer_cid = obj->>'to' and peer_chost = obj->>'tat';	-- Do we recognize the destination entity?

        if recipe ? 'query' then			-- If there a query key in the recipe object
          if not dest_r.id isnull then			-- If destination is a locally known peer
            select into qrec first from mychips.tallies_v_paths where first = dest_r.id and last = from_r.id and corein limit 1;
            if found then return 'affirm'; end if;	-- Do we have a direct pathway from here to the destination peer?
          end if;
--Fixme: check here for max step > local limit (base.parm) and bail if getting too deep

          for qrec in select first,last,path from mychips.tallies_v_paths where last = from_r.id and fora loop	-- Find all upstream paths we might query further
          
-- What to do if we already have a conflicting route in the table:
raise notice 'Further first:% last:% path:% to:% top:% bot:% req:%', qrec.first, qrec.last, qrec.path, obj->>'to', qrec.path[2], from_r.id, requ_r.id;
            select into trec route_ent,dest_chid,topu_ent,botu_ent,requ_ent,native from mychips.routes_v where route_ent = qrec.first and dest_chid = coalesce(dest_r.peer_cid,obj->>'to') and dest_host = coalesce(dest_r.peer_chost,obj->>'tat');
            if found then
raise notice 'Conflict from:% to:% top:% bot:% req:%', trec.route_ent, trec.dest_chid, trec.topu_ent, trec.botu_ent, trec.requ_ent;
              if trec.native then return 'fail'; end if;	-- We found a short-circuit loop that does not resolve to the desired destination: fail
            end if;

            execute 'insert into mychips.routes (route_ent, dest_ent, dest_chid, dest_host, topu_ent, botu_ent, requ_ent) values ($1,$2,$3,$4,$5,$6,$7)
                on conflict (route_ent,dest_chid,dest_host) do nothing'
-- Fixme: We should resurrect old expired routes and retry them
-- like with:   on conflict do update set status = 'draft' where route_state(excluded.status,x,y) something
              using qrec.first, dest_r.id, coalesce(dest_r.peer_cid,obj->>'to'), coalesce(dest_r.peer_chost,obj->>'tat'),
                    qrec.path[2], from_r.id, requ_r.id;
            fwdcnt = fwdcnt + 1;
          end loop;
          if fwdcnt > 0 then
            return 'relay';			-- We relayed the query
          else
            return 'fail';			-- No upstream paths found
          end if;
        end if;					-- query

--Fixme: do I need both kinds of search when normally updating?
        if dest_r.id isnull then
          select into route_r route_ent, dest_ent, dest_chid, dest_host, state from mychips.routes_v where route_ent = from_r.id and dest_chid = obj->>'to' and dest_host = obj->>'tat';
--raise notice '  From:% % to:% % %', from_r.id, from_r.peer_cid, route_r.route_ent, obj->>'to', obj->>'tat';
        else
          select into route_r route_ent, dest_ent, dest_chid, dest_host, state from mychips.routes_v where route_ent = from_r.id and dest_ent = dest_r.id;
--raise notice '  from:% % to:% % %', from_r.id, from_r.peer_cid, dest_r.id, dest_r.peer_cid, dest_r.peer_chost;
        end if;
        curstate = coalesce(route_r.state,'null');		-- Special code for when the route doesn't exist yet

--raise notice ' ent:% state:% recipe:%', route_r.route_ent, curState, recipe;
        if not (jsonb_build_array(curState) <@ (recipe->'context')) then	--Not in any applicable state (listed in our recipe context)
--raise notice 'RZ:% C:%', jsonb_build_array(curState), recipe->'context';
            return curState;
        end if;

        if not route_r.route_ent isnull and recipe ? 'update' then
          qstrg = mychips.state_updater(recipe, 'mychips.routes', '{status}', '{}');
          execute qstrg || ' route_ent = $1 and dest_chid = $2 and dest_host = $3' using route_r.route_ent, route_r.dest_chid, route_r.dest_host;
          delete from mychips.route_tries where rtry_ent = route_r.route_ent and rtry_chid = route_r.dest_chid and rtry_host = route_r.dest_host;
        end if;

      select into route_r route_ent,state from mychips.routes_v where route_ent = route_r.route_ent and dest_chid = route_r.dest_chid and dest_host = route_r.dest_host;
--raise notice '  At end, route % %', route_r.route_ent, route_r.state;
        return route_r.state;
    end;
$$;}

# Check to see if it is time to retry this route check
#----------------------------------------------------------------
function {mychips.route_retry(new mychips.routes)} {mychips.routes} {
  returns boolean language plpgsql as $$
    begin
raise notice 'Route Retry: % %', new.route_ent, new.dest_ent;
--Fixme: How/when do we decide to mark an old record to retry?
    return false;
    end;
$$;}

# Check for possible new route requests associated with a newly created tally
#----------------------------------------------------------------
function {mychips.route_check(new mychips.tallies)} {mychips.tallies mychips.routes mychips.tallies_v_paths} {
  returns void language plpgsql as $$
    declare
      trec	record;
    begin
      for trec in select first,last,path from mychips.tallies_v_paths where length >= 3 and new.tally_ent = any(path) and corein and fora and forz loop
--raise notice 'Route Check: % % % %', new.tally_ent, new.tally_seq, trec.first, trec.last;
        insert into mychips.routes (route_ent, dest_ent, topu_ent, botu_ent, requ_ent) 
          values (trec.first, trec.last, trec.path[2], trec.path[array_upper(trec.path,1)-1], new.tally_ent)
            on conflict (route_ent, dest_chid, dest_host)
              do update set status = 'draft' where mychips.route_retry(excluded);
      end loop;
    end;
$$;}
