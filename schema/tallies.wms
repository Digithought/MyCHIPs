#Schema for storing MyCHIPs tallies
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
#TODO:
#X- Split up tally notice trigger as done for chit trigger
#X- Harden: make limited views specifically for mychips users
#X- Restrict update columns, consolidate to single update
#- Include host_id in tally_v to reduce queries in notice triggers?
#- Add constraints to assure things like contract and signatures in valid tally?
#- 
module mychips
require trigview.tcl
define unitMultiplier 1000

namespace eval tallies {
    def tallies_pk	{tally_ent tally_seq}
    def tallies_v_up	{request comment cr_limit dr_limit}
    def tallies_v_in	[concat tally_ent $tallies_v_up tally_guid tally_type version partner contract user_sig]
    def tallies_se	[concat tally_ent tally_seq $tallies_v_up tally_guid tally_type version partner contract $glob::stampfn tally_date status units_c]

    def chits_pk	{chit_ent chit_seq chit_idx}
    def chits_v_up	{request signature units pro_quo memo}
    def chits_v_in	[concat chit_ent chit_seq $chits_v_up chit_guid chit_type]
    def chits_se	[concat chit_ent chit_seq chit_idx $chits_v_up chit_guid chit_type $glob::stampfn chit_date]
}

table mychips.tallies {mychips mychips.users} {
    tally_ent	text		references mychips.users on update cascade on delete cascade
  , tally_seq	int	      , primary key (tally_ent, tally_seq)
  , tally_guid	uuid		not null
  , tally_type	text		not null default 'stock' check(tally_type in ('stock','foil'))
  , tally_date	timestamptz	not null default current_timestamp
  , version	int		not null default 1 constraint "!mychips.tallies.VER" check (version > 0)
  , partner	text		references base.ent on update cascade on delete restrict
  , status	text		not null default 'void' check(status in ('void','draft','open','close'))
  , request	text		check(request is null or request in ('void','draft','open','close'))
  , comment	text
  , user_sig	text
  , part_sig	text
  , contract	jsonb		-- not null
  , stock_terms	jsonb
  , foil_terms	jsonb
  , bal_target	bigint		not null default 0
  , lift_marg	float		not null default 0 constraint "!mychips.tallies.LMG" check (lift_marg > -1 and lift_marg < 1)
  , drop_marg	float		not null default 1 constraint "!mychips.tallies.DMG" check (drop_marg >= 0 and drop_marg <= 1)
  , dr_limit	bigint		not null default 0
  , cr_limit	bigint		not null default 0
  , units_c	bigint		default 0 not null
    eval(s $glob::stamps)
}
index {} mychips.tallies tally_guid
index {} mychips.tallies tally_type
index {} mychips.tallies tally_date

table mychips.chits {mychips.tallies} {
    chit_ent	text
  , chit_seq	int	      , foreign key (chit_ent, chit_seq) references mychips.tallies on update cascade on delete cascade
  , chit_idx	int	      , primary key (chit_ent, chit_seq, chit_idx)
  , chit_guid	uuid		not null
  , chit_type	text		not null default 'tran' check(chit_type in ('gift','lift','loan','tran'))
  , chit_date	timestamptz	not null default current_timestamp
  , request	text		check(request is null or request in ('userDraft','userRequest','userAgree','userDecline'))
  , signature	text
  , units	bigint		not null
  , pro_quo	text
  , memo	text
    eval(s $glob::stamps)
}
index {} mychips.chits chit_guid
index {} mychips.chits chit_type
index {} mychips.chits chit_date

table mychips.confirms {mychips.tallies} {
    conf_ent	text
  , conf_seq	int	      , foreign key (conf_ent, conf_seq) references mychips.tallies on update cascade on delete cascade
  , conf_idx	int	      , primary key (conf_ent, conf_seq, conf_idx)
  , conf_id	uuid
  , conf_date	timestamptz	not null default current_timestamp
  , sum		bigint		not null
  , signature	text
}

table mychips.tally_tries {mychips.tallies} {
    ttry_ent	text	      , primary key (ttry_ent, ttry_seq)
  , ttry_seq	int	      , foreign key (ttry_ent, ttry_seq) references mychips.tallies on update cascade on delete cascade
  , tries	int		not null default 1
  , last	timestamptz	not null default current_timestamp
}

table mychips.chit_tries {mychips.chits} {
    ctry_ent	text	      , primary key (ctry_ent, ctry_seq, ctry_idx)
  , ctry_seq	int
  , ctry_idx	int	      , foreign key (ctry_ent, ctry_seq, ctry_idx) references mychips.chits on update cascade on delete cascade
  , tries	int		not null default 1
  , last	timestamptz	not null default current_timestamp
}

# Generate unique sequence for new tallies
#----------------------------------------------------------------
function mychips.tallies_tf_seq() {mychips.tallies} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.tally_seq is null then
            select into new.tally_seq coalesce(max(tally_seq),0)+1 from mychips.tallies where tally_ent = new.tally_ent;
        end if;
        return new;
    end;
$$;}
trigger mychips_tallies_tr_seq {} {
    before insert on mychips.tallies for each row execute procedure mychips.tallies_tf_seq();
}

# Generate unique sequence for new chit
#----------------------------------------------------------------
function mychips.chits_tf_seq() {mychips.chits} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.chit_idx is null then
            select into new.chit_idx coalesce(max(chit_idx),0)+1 from mychips.chits where chit_ent = new.chit_ent and chit_seq = new.chit_seq;
        end if;
        return new;
    end;
$$;}
trigger mychips_chits_tr_seq {} {
    before insert on mychips.chits for each row execute procedure mychips.chits_tf_seq();
}

# Cache the total of tallies when the chits change
#----------------------------------------------------------------
function mychips.chits_tf_cache() {mychips} {
  returns trigger language plpgsql security definer as $$
    declare
      trec	record;
    begin
      if TG_OP = 'DELETE' then trec = old; else trec = new; end if;
      update mychips.tallies set units_c = (select coalesce(sum(units),0) from mychips.chits where chit_ent = trec.chit_ent and chit_seq = trec.chit_seq) where tally_ent = trec.chit_ent and tally_seq = trec.chit_seq;
      return null;
    end;
$$;}
trigger mychips_chits_tr_cache {} {
    after insert or update or delete on mychips.chits for each row execute procedure mychips.chits_tf_cache();
}

# Generate unique sequence for new confirmation
#----------------------------------------------------------------
function mychips.confirms_tf_seq() {mychips.confirms} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.conf_idx is null then
            select into new.conf_idx coalesce(max(conf_idx),0)+1 from mychips.confirms where conf_ent = new.conf_ent and conf_seq = new.conf_seq;
        end if;
        return new;
    end;
$$;}
trigger mychips_confirms_tr_seq {} {
    before insert on mychips.confirms for each row execute procedure mychips.confirms_tf_seq();
}

# Notify the peer server process of tally state changes, and next state request, that needs attention in the database
#----------------------------------------------------------------
function {mychips.tally_notify(tally mychips.tallies)} {mychips.tallies mychips.tallies_v mychips.users_v mychips.peers_v mychips.tally_tries} {
  returns boolean language plpgsql security definer as $$
    declare
        act	text;
        jrec	jsonb = '{"target": "tally"}';
        urec	record;			-- User
        prec	record;			-- Peer
        trec	record;			-- Tally
        rrec	record;			-- Retries
        channel	text = 'mychips_peer';
    begin
        if tally.status = 'void'  and tally.request = 'draft' then	-- Determine next action
            act = 'userDraft';
        elsif tally.status = 'draft' and tally.request = 'void'  then
            act = 'userVoid';
        elsif tally.status = 'draft' and tally.request = 'open'  then
            act = 'userAccept';
        elsif tally.status = 'open'  and tally.request = 'close' then
            act = 'userClose';
        end if;
--raise notice 'TN:% % %', act, tally.tally_ent, tally.partner;
        if act is null then return false; end if;
        select into trec status,request,state,json from mychips.tallies_v where tally_ent = tally.tally_ent and tally_seq = tally.tally_seq;
        select into urec peer_cdi, host_id from mychips.users_v where user_ent = tally.tally_ent;
        select into prec peer_cdi, peer_sock from mychips.peers_v where peer_ent = tally.partner;
        if not urec.host_id is null then
            channel = channel || '_' || urec.host_id;
        end if;

        insert into mychips.tally_tries (ttry_ent, ttry_seq) values (tally.tally_ent, tally.tally_seq)
          on conflict (ttry_ent,ttry_seq) do update set tries = mychips.tally_tries.tries + 1, last = current_timestamp
            returning * into rrec;
--raise notice 'Tn c:% h:% p:% u:% s:%', channel, urec.host_id, prec.peer_cdi, urec.peer_cdi, prec.peer_sock;
        jrec = jsonb_set(jrec, '{peer}', to_jsonb(prec.peer_cdi));
        jrec = jsonb_set(jrec, '{user}', to_jsonb(urec.peer_cdi));
        jrec = jsonb_set(jrec, '{entity}', to_jsonb(tally.tally_ent));
        jrec = jsonb_set(jrec, '{action}', to_jsonb(act));
        jrec = jsonb_set(jrec, '{try}', to_jsonb(rrec.tries));
        jrec = jsonb_set(jrec, '{last}', to_jsonb(rrec.last));
        jrec = jsonb_set(jrec, '{at}', coalesce(to_jsonb(prec.peer_sock),'null'::jsonb));
        jrec = jsonb_set(jrec, '{object}', trec.json);
-- raise notice 'Tally notice:%', jrec::text;
        perform pg_notify(channel, jrec::text);			-- Notify peer server of next state action request
        
        return true;
    end;
$$;}

# Generate notifications about updated tallies for listening peer servers
#----------------------------------------------------------------
function mychips.tallies_tf_notify() {mychips.tally_notify(mychips.tallies)} {
  returns trigger language plpgsql security definer as $$
    declare
        dirty	boolean default false;
    begin
        if TG_OP = 'INSERT' then
            dirty = true;
        elsif new.request is not null and new.request is distinct from old.request then
            dirty = true;
        end if;
        if dirty then perform mychips.tally_notify(new); end if;
        return new;
    end;
$$;}
trigger mychips_tallies_tr_notice {} {
    after insert or update on mychips.tallies for each row execute procedure mychips.tallies_tf_notify();
}

# Compute current state of a tally, based on its various fields
#----------------------------------------------------------------
function {mychips.tally_state(status text, request text, user_sig text, part_sig text, total bigint)} {mychips} {
  returns text immutable language plpgsql as $$
    begin
      return case when status = 'void' and request is null	then 'void'
         when status = 'void' and request = 'draft'		then 'userDraft'
         when status = 'draft' and request is null then
           case when user_sig is not null and part_sig is null	then 'userProffer'
                when part_sig is not null and user_sig is null	then 'peerProffer'
           else 'undefined' end
         when status = 'draft' and request = 'void'		then 'userVoid'
         when status = 'draft' and request = 'open'		then 'accepted'
         when status = 'open' and request is null		then 'open'
         when status = 'open' and request = 'close'		then 'userClose'
         when status = 'close' and request is null then
             case when total = 0 then 'closed' else 'closing' end
         else 'undefined' end;
    end;
$$;}

# Base view of tallies
#----------------------------------------------------------------
define multSign {case when te.tally_type = 'stock' then unitMultiplier().00 else -unitMultiplier().00 end}
view mychips.tallies_v {mychips.tallies mychips.chits mychips.users_v mychips.peers_v} {select 
    eval(fld_list $tallies::tallies_se	te)
  , ue.peer_cdi		as user_cdi
  , ue.peer_sock	as user_sock
  , ue.std_name		as user_name
  , te.user_sig
  , pe.peer_cdi		as part_cdi
  , pe.peer_sock	as part_sock
  , pe.std_name		as part_name
  , te.part_sig
  , mychips.tally_state(status,request,user_sig,part_sig,units_c) as state
  , mychips.tally_state(status,request,user_sig,part_sig,units_c) = any(array['peerProffer','closing']) as action
  , jsonb_build_object(
       'guid', te.tally_guid,
       'version', te.version,
       'stock', case when te.tally_type = 'stock' then ue.peer_cdi else pe.peer_cdi end,
       'foil',  case when te.tally_type = 'stock' then pe.peer_cdi else ue.peer_cdi end,
       'created', te.tally_date,
       'contract', te.contract,
       'signed', json_build_object(
         'digest', '',
         'stock', case when te.tally_type = 'stock' then te.user_sig else te.part_sig end,
         'foil',  case when te.tally_type = 'stock' then te.part_sig else te.user_sig end
       )
    )			as json
  , coalesce(tc.units,0)			as units
  , te.units_c::float8 / multSign()		as total_c
  , coalesce(tc.units,0)::float8 / multSign()	as total
  , coalesce(tc.chits,0)			as chits
  , coalesce(tc.latest,te.mod_date)		as latest

    from	mychips.tallies	te
    join	mychips.users_v	ue on ue.user_ent = te.tally_ent
    join	mychips.peers_v	pe on pe.peer_ent = te.partner
    left join	(select chit_ent, chit_seq, sum(units) as units, count(chit_idx) as chits, max(mod_date) as latest from mychips.chits group by 1,2) tc on tc.chit_ent = te.tally_ent and tc.chit_seq = te.tally_seq;

    eval(trigview::insert mychips.tallies_v mychips.tallies $tallies::tallies_v_in $tallies::tallies_pk [concat $glob::stampin {request 'draft'}]);
    eval(trigview::update mychips.tallies_v mychips.tallies $tallies::tallies_v_up $tallies::tallies_pk $glob::stampup);
}

# User view of tallies
#----------------------------------------------------------------
view mychips.tallies_v_me {mychips.tallies_v base.user_id(text)} {select 
    t.*
    from	mychips.tallies_v t
    where	t.tally_ent = base.user_id(session_user)
} -grant {
    {tally	{s} {s i u} {d}}
}

# Summarize data about tallies
#----------------------------------------------------------------
view mychips.tallies_v_sum {mychips.tallies_v} {select 
    tally_ent
  , count(tally_seq)	as tallies
  , sum(total_c)	as total_c
  , sum(total)		as total
  , sum(case when tally_type = 'stock' then total_c else 0 end)	as stock_total_c
  , sum(case when tally_type = 'stock' then total else 0 end)	as stock_total
  , sum(case when tally_type = 'foil' then total_c else 0 end)	as foil_total_c
  , sum(case when tally_type = 'foil' then total else 0 end)	as foil_total
  , count(nullif(tally_type, 'foil'))::int4	as stocks
  , count(nullif(tally_type, 'stock'))::int4	as foils
  , array_agg(partner)	as partners
  , array_agg(partner) filter (where tally_type = 'stock')	as clients
  , array_agg(partner) filter (where tally_type = 'foil')	as vendors
  , array_agg(part_cdi)	as partner_cdis
  , array_agg(part_cdi) filter (where tally_type = 'stock')	as client_cdis
  , array_agg(part_cdi) filter (where tally_type = 'foil')	as vendor_cdis
  , max(latest)							as latest
  from mychips.tallies_v group by 1;
}

# View showing a single entry for each credit relationship (for network graph)
#----------------------------------------------------------------
view mychips.tallies_v_graph {mychips.tallies_v} {select 
    tally_guid as guid    
  , case when tally_type = 'stock' then tally_ent else partner end as stock_ent
  , case when tally_type = 'stock' then partner else tally_ent end as foil_ent
  , case when tally_type = 'stock' then user_cdi else part_cdi end as stock_cdi
  , case when tally_type = 'stock' then part_cdi else user_cdi end as foil_cdi
  , case when tally_type = 'stock' then total_c else -total_c end as total
  , state
  , max(latest) as latest
  
  from mychips.tallies_v group by 1,2,3,4,5,6,7;
}

# Process tally state transitions requested by the peer server process
#----------------------------------------------------------------
function {mychips.tally_process(msg jsonb, recipe jsonb)} {mychips.tallies_v mychips.users_v} {
  returns text language plpgsql as $$
    declare
        cdi		text = msg->>'user';
        obj		jsonb = msg->'object';
        guid		uuid = obj->>'guid';
        curState	text;
        qflds		text[];		-- Temporary array
        qstrg		text;		-- Temporary string
        erec		record;		-- Tally entity, we will ignore the one in msg
        lrec		record;		-- Looping variable
        trec		record;		-- Holds tally record(s)
        jrec		jsonb = '{"target": "tally"}';
        channel	text = 'mychips_user';
        tallyType text; notType text; partner text;
    begin
        select into erec id,host_id from mychips.users_v where peer_cdi = cdi;	-- Look up the entity on our own
        if not found then return null; end if;

        select into trec tally_ent, tally_seq, state from mychips.tallies_v where tally_ent = erec.id and tally_guid = guid;
        curState = trec.state;
--raise notice 'Tally cdi:% entity:% state:% recipe:%', cdi, erec.id, curState, recipe;
        if not found then
            curState = 'null';			-- Special code for when the tally doesn't exist yet
        end if;
        if not (jsonb_build_array(curState) <@ (recipe->'context')) then	--Not in any applicable state (listed in our recipe context)
--raise notice 'Z:% C:%', jsonb_build_array(curState), recipe->'context';
            return curState;
        end if;

        if recipe ? 'upsert' then		-- If there an upsert key in the recipe object?
--raise notice '  upsert obj:% curState:%', obj, curState;
          tallyType = (case when obj->>'stock' = cdi then 'stock' else 'foil' end);
          notType = (case when obj->>'stock' = cdi then 'foil' else 'stock' end);
--raise notice '  tallyType:% notType:%', tallyType, notType;
          if curState = 'null' then			-- Need to do insert
            select into partner peer_ent from mychips.peers where peer_cdi = case when tallyType = 'stock' then obj->>'foil' else obj->>'stock' end;
            if not found then return null; end if;
            
            execute 'insert into mychips.tallies (tally_ent,tally_guid,tally_type,tally_date,version,partner,contract,status,comment,user_sig,part_sig,cr_limit,dr_limit) values ($1,$2,$3,current_timestamp,$4,$5,$6,$7,$8,$9,$10,$11,$12) returning tally_ent, tally_seq' into trec
                using erec.id, guid, tallyType, (obj->>'version')::int, partner, obj->'contract', 'draft', obj->'comment', obj->'signed'->>tallyType, obj->'signed'->>notType, coalesce((obj->>'crLimit')::bigint,0), coalesce((obj->>'drLimit')::bigint,0);
          else						-- Tally already exists, do update
            execute 'update mychips.tallies set version = $1, contract = $2, status = $3, comment = $4, user_sig = $5, part_sig = $6, cr_limit = $7, dr_limit = $8 request = null where tally_ent = $9 and tally_seq = $10'
                using (obj->>'version')::int, obj->'contract', 'draft', obj->'comment', obj->'signed'->>tallyType, obj->'signed'->>notType, coalesce((obj->>'crLimit')::bigint,0), coalesce((obj->>'drLimit')::bigint,0), trec.tally_ent, trec.tally_seq;
            delete from mychips.tally_tries where ttry_ent = trec.tally_ent and ttry_seq = trec.tally_seq;
          end if;
        end if;

        if recipe ? 'update' then		-- There's an update key in the recipe
          qflds = '{}';
          for lrec in select * from jsonb_each_text(recipe->'update') loop
--raise notice '  update set % = %', lrec.key, lrec.value;
            if lrec.key = any('{status, part_sig}') then		-- enumerate writable fields
              qflds = qflds || (quote_ident(lrec.key) || ' = ' || quote_nullable(lrec.value));
            end if;
          end loop;
          qstrg = 'update mychips.tallies set request = null, ' || array_to_string(qflds,', ') || ' where tally_ent = $2 and tally_seq = $3';
--raise notice 'SQL:%', qstrg;
          execute qstrg using lrec.value, trec.tally_ent, trec.tally_seq;
          delete from mychips.tally_tries where ttry_ent = trec.tally_ent and ttry_seq = trec.tally_seq;
        end if;

--raise notice '  At end, tally % %', trec.tally_ent, trec.tally_seq;
        select into trec tally_ent,tally_seq,state,action,json from mychips.tallies_v where tally_ent = trec.tally_ent and tally_seq = trec.tally_seq;
        if trec.action or (trec.state = 'open' and curState is distinct from 'open') then	-- Also notify if changed to open status
            if not erec.host_id is null then channel = channel || '_' || erec.host_id; end if;
--raise notice '  tally notify for user channel: % %', channel, trec.json;
            jrec = jsonb_set(jrec, '{entity}', to_jsonb(trec.tally_ent));
            jrec = jsonb_set(jrec, '{sequence}', to_jsonb(trec.tally_seq));
            jrec = jsonb_set(jrec, '{state}', to_jsonb(trec.state));
            jrec = jsonb_set(jrec, '{object}', trec.json);
            perform pg_notify(channel, jrec::text);
--            perform pg_notify('mychips_admin', trec.json::text);	Do we need this?
        end if;
        return trec.state;
    end;
$$;}

# Notify the peer server process of chit state changes that need attention in the database
#----------------------------------------------------------------
function {mychips.chit_notify(chit mychips.chits)} {mychips.users_v mychips.chits_v mychips.tallies_v mychips.chit_tries} {
  returns boolean language plpgsql security definer as $$
    declare
        act	text	= chit.request;
        jrec	jsonb	= '{"target": "chit"}';
        channel	text	= 'mychips_peer';
        trec	record;			-- Talley
        urec	record;			-- User
        rrec	record;			-- Retries
    begin
        if act is null then return false; end if;
        
        select into trec * from mychips.tallies_v where tally_ent = chit.chit_ent and tally_seq = chit.chit_seq;
        select into urec host_id from mychips.users_v where user_ent = chit.chit_ent;
        if not urec.host_id is null then
            channel = channel || '_' || urec.host_id;
        end if;
        insert into mychips.chit_tries (ctry_ent, ctry_seq, ctry_idx) values (chit.chit_ent, chit.chit_seq, chit.chit_idx)
          on conflict (ctry_ent,ctry_seq,ctry_idx) do update set tries = mychips.chit_tries.tries + 1, last = current_timestamp
            returning * into rrec;
        
        jrec = jsonb_set(jrec, '{peer}', to_jsonb(trec.part_cdi));
        jrec = jsonb_set(jrec, '{user}', to_jsonb(trec.user_cdi));
        jrec = jsonb_set(jrec, '{entity}', to_jsonb(chit.chit_ent));
        jrec = jsonb_set(jrec, '{tally}', to_jsonb(trec.tally_guid));
        jrec = jsonb_set(jrec, '{action}', to_jsonb(act));
        jrec = jsonb_set(jrec, '{try}', to_jsonb(rrec.tries));
        jrec = jsonb_set(jrec, '{last}', to_jsonb(rrec.last));
        jrec = jsonb_set(jrec, '{at}', to_jsonb(trec.part_sock));
        jrec = jsonb_set(jrec, '{object}', (select json from mychips.chits_v where chit_ent = chit.chit_ent and chit_seq = chit.chit_seq and chit_idx = chit.chit_idx));
raise notice 'Chit notice:% %', channel, jrec::text;
        perform pg_notify(channel, jrec::text);
        return true;
    end;
$$;}

# Generate notifications about updated chits for listening peer servers
#----------------------------------------------------------------
function mychips.chits_tf_notify() {mychips.chits mychips.chits_v mychips.tallies_v} {
  returns trigger language plpgsql security definer as $$
    declare
        dirty	boolean default false;
    begin
        if TG_OP = 'INSERT' then
            dirty = true;
        elsif new.request is not null and new.request is distinct from old.request then
            dirty = true;
        end if;
--raise notice 'Chit update: %', dirty;
        if dirty then perform mychips.chit_notify(new); end if;
        return new;
    end;
$$;}
trigger mychips_chits_tr_notice {} {
    after insert or update on mychips.chits for each row execute procedure mychips.chits_tf_notify();
}

# Compute current state of this chit
#----------------------------------------------------------------
function {mychips.chit_state(isdebit boolean, request text, signature text)} {mychips} {
  returns text immutable language plpgsql as $$
    begin return
      case when isdebit then
        case when signature = 'void'		then 'peerDecline'
           when signature is not null		then 'peerValid'
           when request = 'userRequest'		then 'userRequest'
           when request is null			then 'userInvoice'
           else					     'undefined'	end
      else	--is a credit
        case when signature = 'void' then
        case when request = 'userDecline'	then 'userDecline'
             when request is null		then 'userVoid'
             else				     'undefined'    end
           when signature is null then
        case when request is null		then 'peerInvoice'
             else				     'undefined'    end
           when request = 'userAgree'		then 'userAgree'
           when request = 'userDraft'		then 'userDraft'
           when request is null			then 'userValid'
      else     					     'undefined'	end
      end;
    end;
$$;}

# Base view of chits
#----------------------------------------------------------------
define isdebit {te.tally_type = 'stock' and ch.units >= 0 or te.tally_type = 'foil' and ch.units < 0}
view mychips.chits_v {mychips.chits mychips.tallies_v mychips.chit_state(boolean,text,text)} {select 
    eval(fld_list $tallies::chits_se	ch)
  , te.user_cdi
  , te.part_cdi
  , te.tally_type
  , case when isdebit() then 'debit' else 'credit' end		as effect
         
  , ch.units::float8 / unitMultiplier().00	as value
  , ch.units::float8 * case when te.tally_type = 'stock' then 1 else -1 end / unitMultiplier()	as amount
  , mychips.chit_state(isdebit(), ch.request, ch.signature)	as state
  , mychips.chit_state(isdebit(), ch.request, ch.signature) = any(array['peerInvoice','peerDecline']) as action
  , jsonb_build_object(
       'guid',		ch.chit_guid,
       'type',		ch.chit_type,
       'date',		ch.chit_date,
       'units',		ch.units,
       'signed',	ch.signature
  )						as json
    from	mychips.chits		ch
    join	mychips.tallies_v	te on te.tally_ent = ch.chit_ent and te.tally_seq = ch.chit_seq
} -grant {
    {chit	{s} {i u} {d}}
}

# User view of chits
#----------------------------------------------------------------
view mychips.chits_v_me {mychips.chits_v mychips.tallies_v_me} {select 
    c.*
    from	mychips.chits_v c
    join	mychips.tallies_v_me t on c.chit_ent = t.tally_ent and c.chit_seq = t.tally_seq
} -grant {
    {chit	{s} {s i u} {d}}
}

# Process chit state transitions requested by the peer server process
#----------------------------------------------------------------
function {mychips.chit_process(msg jsonb, recipe jsonb)} {mychips.users_v mychips.chits_v} {
  returns text language plpgsql as $$
    declare
        cdi		text	= msg->>'user';
        obj		jsonb	= msg->'object';
        guid		uuid	= obj->>'guid';
        curState	text;
        crec		record;
        trec		record;
        lrec		record;
        erec		record;
        channel	text = 'mychips_user';
    begin
        select into erec id, host_id from mychips.users_v where peer_cdi = cdi;
        if not found then return null; end if;

        select into crec chit_ent, chit_seq, chit_idx, state from mychips.chits_v where chit_ent = erec.id and chit_guid = guid;
        curState = crec.state;
raise notice 'Chit cdi:% entity:% state:% recipe:%', cdi, crec.chit_ent, curState, recipe;
        if not found then
            curState = 'null';		-- Special code for when the specified chit doesn't exist yet
        end if;

        if not (jsonb_build_array(curState) <@ (recipe->'context')) then	--Not in any applicable state
raise notice 'Z:% C:%', jsonb_build_array(curState), recipe->'context';
            return curState;
        end if;

        if recipe ? 'upsert' then
raise notice '  upsert obj:% curState:%', obj, curState;
          if curState = 'null' then			-- Need to do insert
            select into trec * from mychips.tallies where tally_ent = erec.id and tally_guid = (msg->>'tally')::uuid;
            if not found then return null; end if;
            
            execute 'insert into mychips.chits (chit_ent,chit_seq,chit_guid,chit_type,chit_date,signature,units,pro_quo,memo) values ($1,$2,$3,$4,current_timestamp,$5,$6,$7,$8) returning chit_ent, chit_seq, chit_idx' into crec
                using trec.tally_ent, trec.tally_seq, guid, obj->>'type', obj->>'signed', (obj->>'units')::bigint, obj->>'link', obj->>'memo';
          else						-- Chit already exists, do update
            execute 'update mychips.chits set signature = $1, units = $2, pro_quo = $3, memo = $4, request = null where chit_ent = $5 and chit_seq = $6 and chit_idx = $7'
                using obj->>'signed', (obj->>'units')::bigint, obj->>'link', obj->>'memo', crec.chit_ent, crec.chit_seq, crec.chit_idx;
            delete from mychips.chit_tries where ctry_ent = crec.chit_ent and ctry_seq = crec.chit_seq and ctry_idx = crec.chit_idx;
          end if;
        end if;

        if recipe ? 'update' then
          for lrec in select * from jsonb_each_text(recipe->'update') loop	--Fixme: should probably restrict which columns can be updated by this method
raise notice '  update set % = %', lrec.key, lrec.value;
            execute 'update mychips.chits set ' || lrec.key || ' = $1 where chit_ent = $2 and chit_seq = $3 and chit_idx = $4' using lrec.value, crec.chit_ent, crec.chit_seq, crec.chit_idx;
          end loop;
          update mychips.chits set request = null where chit_ent = crec.chit_ent and chit_seq = crec.chit_seq and chit_idx = crec.chit_idx;
          delete from mychips.chit_tries where ctry_ent = crec.chit_ent and ctry_seq = crec.chit_seq and ctry_idx = crec.chit_idx;
        end if;

        select into crec chit_ent,chit_seq,chit_idx,state,action,json from mychips.chits_v where chit_ent = crec.chit_ent and chit_seq = crec.chit_seq and chit_idx = crec.chit_idx;
        if crec.action or (crec.state = 'peerValid' and (curState is distinct from 'peerValid')) then	-- Also notify if changed to valid status
            if not erec.host_id is null then
              channel = channel || '_' || erec.host_id;
            end if;
raise notice '  chit notify for user channel: %', channel;
            perform pg_notify(channel, trec.json::text);
--            perform pg_notify('mychips_admin', crec.json::text);	Do we need this?
        end if;
        return crec.state;
    end;
$$;}

# Check for any lingering, unprocessed notices
# A peer server should call this on launch to become aware of any activity it has missed
#----------------------------------------------------------------
function {mychips.tally_notices()} {mychips.tallies mychips.tally_tries mychips.chits base.parm_int(text,text)} {
  returns int language plpgsql as $$
    declare
        trec		mychips.tallies;
        crec		mychips.chits;
        didem		int = 0;
        min_min		int = coalesce(base.parm_int('peers','min_time'), 60);
        min_time	interval = (min_min::text || ' minutes')::interval;
    begin
        for trec in select * from mychips.tallies ta	-- tokens stale by peer_min_time
          join mychips.tally_tries tr on tr.ttry_ent = ta.tally_ent and tr.ttry_seq = ta.tally_seq
          where ta.request is not null and (current_timestamp - tr.last) >= min_time loop
            perform mychips.tally_notify(trec);
            didem = didem + 1;
        end loop;

        for crec in select * from mychips.chits ch
          join mychips.chit_tries ct on ct.ctry_ent = ch.chit_ent and ct.ctry_seq = ch.chit_seq and ct.ctry_idx = ch.chit_idx
          where ch.request is not null and (current_timestamp - ct.last) >= min_time loop
            perform mychips.chit_notify(crec);
            didem = didem + 1;
        end loop;
        return didem;
    end;
$$;}

# Generate notifications about new or updated tallies for listening admin servers
#----------------------------------------------------------------
function mychips.change_tf_notify() {mychips} {
  returns trigger language plpgsql security definer as $$
    begin
--raise notice 'Change notify: mychips_admin';
      perform pg_notify('mychips_admin', format('{"target":"%s", "oper":"%s", "time":"%s"}', coalesce(TG_ARGV[0],'Unknown'), TG_OP, transaction_timestamp()::text));
      return null;
    end;
$$;}
trigger mychips_tallies_tr_change {} {
    after insert or update or delete on mychips.tallies for each statement execute procedure mychips.change_tf_notify('tallies');
}
trigger mychips_chits_tr_change {} {
    after insert or update or delete on mychips.chits for each statement execute procedure mychips.change_tf_notify('chits');
}

# Find an open tally meeting certain criteria, returning the sequence number (currently used only in agent1 model)
#----------------------------------------------------------------
function {mychips.tally_find(ent text, part text, typ text)} {mychips.tallies} {
  returns int immutable language plpgsql as $$
    declare
      trec record;
    begin
      select into trec * from mychips.tallies where tally_ent = ent and status = 'open' and tally_type = typ and partner = part order by crt_date desc limit 1;
      return trec.tally_seq;
    end;
$$;}
