#Schema for storing MyCHIPs tallies
#Copyright MyCHIPs.org: GNU GPL Ver 3; see: License in root of this package
#TODO:
#- Insert dummy tally records
#- Test tallies_v
#- Create insert, update, delete triggers for view
#- Implement triggers to generate notify events to peer server
#- Implement triggers to generate notify events to user server
#- 
module mychips

namespace eval tallies {
    def tallies_pk	{tally_ent tally_seq}
    def tallies_v_up	{request comment cr_limit dr_limit}
    def tallies_v_in	[concat tally_ent $tallies_v_up partner contract]
    def tallies_se	[concat $tallies_v_in $glob::stampfn]
    def ent_se		{std_name frm_name}
#    def ent_v_in	$base::ent_v_in
#    def ent_v_up	[lremove $base::ent_v_up ent_type username]
}

table mychips.tallies {mychips base.ent} {
    tally_ent	int		references base.ent on update cascade on delete cascade
  , tally_seq	int	      , primary key (tally_ent, tally_seq)
  , tally_guid	uuid		not null
  , tally_type	varchar		not null default 'stock' check(tally_type in ('stock','foil'))
  , tally_date	timestamptz	not null default current_timestamp
  , version	int		not null default 1 constraint "!mychips.tallies.VER" check (version > 0)
  , partner	int		references base.ent on update cascade on delete restrict
  , contract	varchar	--	references mychips.covenants on update cascade on delete restrict
  , status	varchar		not null default 'void' check(status in ('void','draft','open','close'))
  , request	varchar		check(request is null or request in ('void','draft','open','close'))
  , comment	varchar
  , cr_limit	bigint		not null default 0 constraint "!mychips.tallies.FLM" check (cr_limit >= 0)
  , dr_limit	bigint		not null default 0 constraint "!mychips.tallies.RLM" check (dr_limit >= 0)
  , total_c	bigint		default 0 not null
    eval(s $glob::stamps)
}

table mychips.chits {mychips.tallies} {
    chit_ent	int
  , chit_seq	int	      , foreign key (chit_ent, chit_seq) references mychips.tallies on update cascade on delete cascade
  , chit_idx	int	      , primary key (chit_ent, chit_seq, chit_idx)
  , chit_guid	uuid		not null
  , chit_type	varchar		not null default 'tran' check(chit_type in ('gift','lift','loan','tran'))
  , chit_date	timestamptz	not null default current_timestamp
  , expires	timestamptz	not null default current_timestamp
  , signature	varchar
  , amount	bigint		not null
  , pro_quo	varchar
  , memo	varchar
}

table mychips.confirms {mychips.tallies} {
    conf_ent	int
  , conf_seq	int	      , foreign key (conf_ent, conf_seq) references mychips.tallies on update cascade on delete cascade
  , conf_idx	int	      , primary key (conf_ent, conf_seq, conf_idx)
  , conf_id	uuid
  , conf_date	timestamptz	not null default current_timestamp
  , sum		bigint		not null
  , signature	varchar
}

# Generate unique sequence for new tallies
#----------------------------------------------------------------
function mychips.tallies_tf_seq() {mychips.tallies} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.tally_seq is null then
            select into new.tally_seq coalesce(max(tally_seq),0)+1 from mychips.tallies where tally_ent = new.tally_ent;
        end if;
        return new;
    end;
$$;}
trigger mychips_tallies_tr_seq {} {
    before insert on mychips.tallies for each row execute procedure mychips.tallies_tf_seq();
}

# Generate unique sequence for new chit
#----------------------------------------------------------------
function mychips.chits_tf_seq() {mychips.chits} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.chit_idx is null then
            select into new.chit_idx coalesce(max(chit_idx),0)+1 from mychips.chits where chit_ent = new.chit_ent and chit_seq = new.chit_seq;
        end if;
        return new;
    end;
$$;}
trigger mychips_chits_tr_seq {} {
    before insert on mychips.chits for each row execute procedure mychips.chits_tf_seq();
}

# Generate unique sequence for new confirmation
#----------------------------------------------------------------
function mychips.confirms_tf_seq() {mychips.confirms} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.conf_idx is null then
            select into new.conf_idx coalesce(max(conf_idx),0)+1 from mychips.confirms where conf_ent = new.conf_ent and conf_seq = new.conf_seq;
        end if;
        return new;
    end;
$$;}
trigger mychips_confirms_tr_seq {} {
    before insert on mychips.confirms for each row execute procedure mychips.confirms_tf_seq();
}

# Generate unique sequence for new tallies
#----------------------------------------------------------------
function mychips.tallies_tf_notice() {mychips.tallies} {
  returns trigger language plpgsql security definer as $$
    declare
        orec	record;
    begin
        if (new.request = old.request and new.status = old.status) then
            return new;
        end if;
        if new.status = 'void' and new.request = 'draft' then
          notify mychips_peer, '{"target": "tally", "action": "userDraft"}';
        elsif  new.status = 'draft' and new.request = 'void' then
          notify mychips_peer, '{"target": "tally", "action": "userVoid"}';
        elsif  new.status = 'draft' and new.request = 'open' then
          notify mychips_peer, '{"target": "tally", "action": "userAccept"}';
        elsif  new.status = 'open' and new.request = 'close' then
          notify mychips_peer, '{"target": "tally", "action": "userClose"}';
        end if;
        return new;
    end;
$$;}
trigger mychips_tallies_tr_notice {} {
    after update on mychips.tallies for each row execute procedure mychips.tallies_tf_notice();
}

# Base view of tallies
#----------------------------------------------------------------
#view mychips.tallies_v {mychips.tallies base.ent_v} {select 
#    eval(fld_list $tallies::tallies_se	te)
#  , eval(fld_list $tallies::ent_se	ue)
#  , host(mobi_inet) || ':' || mobi_port	as mobi_sock
#
#    from	mychips.tallies	te
#    join	mychips.users	ue on ue.user_ent = te.tally_ent
#    join	mychips.users	pe on pe.user_ent = te.partner;
#
#--    ev-al(multiview::insert mychips.users_v "
#--        {base.ent	{$base::ent_v_in}	{$base::ent_pk}		{$glob::stampup}}
#--        {mychips.users	{$users::users_v_in}	{$users::users_pk}}
#--    ")
#--    ev-al(multiview::update mychips.users_v "
#--        {base.ent	{$users::ent_v_up}	{$base::ent_pk}		{$glob::stampup}}
#--        {mychips.users	{$users::users_v_up}	{$users::users_pk}	{$glob::stampup}}
#--    ")
#--    ev-al(multiview::delete mychips.users_v "
#--        {mychips.users	{$users::users_pk}	{(old.crt_by = session_user and (current_timestamp - old.crt_date) < '2 hours'::interval) or base.priv_has('userim',3)}}
#--    ")
#} -grant {
#    {mychips	{} {s i u} {d}}
#} -primary id
