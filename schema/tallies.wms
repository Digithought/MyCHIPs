#Schema for storing MyCHIPs tallies
#Copyright MyCHIPs.org: GNU GPL Ver 3; see: License in root of this package
#TODO:
#- Insert dummy tally records
#- Test tallies_v
#- Create insert, update, delete triggers for view
#- Implement triggers to generate notify events to peer server
#- Implement triggers to generate notify events to user server
#- Instantiate 'state' as a cached field in tallies table, update in trigger?
module mychips

namespace eval tallies {
    def tallies_pk	{tally_ent tally_seq}
    def tallies_v_up	{request comment cr_limit dr_limit}
    def tallies_v_in	[concat tally_ent $tallies_v_up tally_guid tally_type version partner contract]
    def tallies_se	[concat $tallies_v_in $glob::stampfn tally_date status]
#    def users_se	{user_cdi std_name frm_name}
#    def ent_v_in	$base::ent_v_in
#    def ent_v_up	[lremove $base::ent_v_up ent_type username]
}

table mychips.tallies {mychips base.ent} {
    tally_ent	int		references base.ent on update cascade on delete cascade
  , tally_seq	int	      , primary key (tally_ent, tally_seq)
  , tally_guid	uuid		not null
  , tally_type	varchar		not null default 'stock' check(tally_type in ('stock','foil'))
  , tally_date	timestamptz	not null default current_timestamp
  , version	int		not null default 1 constraint "!mychips.tallies.VER" check (version > 0)
  , partner	int		references base.ent on update cascade on delete restrict
  , contract	varchar	     -- references mychips.covenants on update cascade on delete restrict
  , status	varchar		not null default 'void' check(status in ('void','draft','open','close'))
  , request	varchar		check(request is null or request in ('void','draft','open','close'))
  , comment	varchar
  , user_sig	varchar
  , part_sig	varchar
  , cr_limit	bigint		not null default 0 constraint "!mychips.tallies.FLM" check (cr_limit >= 0)
  , dr_limit	bigint		not null default 0 constraint "!mychips.tallies.RLM" check (dr_limit >= 0)
  , total_c	bigint		default 0 not null
    eval(s $glob::stamps)
}

table mychips.chits {mychips.tallies} {
    chit_ent	int
  , chit_seq	int	      , foreign key (chit_ent, chit_seq) references mychips.tallies on update cascade on delete cascade
  , chit_idx	int	      , primary key (chit_ent, chit_seq, chit_idx)
  , chit_guid	uuid		not null
  , chit_type	varchar		not null default 'tran' check(chit_type in ('gift','lift','loan','tran'))
  , chit_date	timestamptz	not null default current_timestamp
  , expires	timestamptz	not null default current_timestamp
  , signature	varchar
  , amount	bigint		not null
  , pro_quo	varchar
  , memo	varchar
}

table mychips.confirms {mychips.tallies} {
    conf_ent	int
  , conf_seq	int	      , foreign key (conf_ent, conf_seq) references mychips.tallies on update cascade on delete cascade
  , conf_idx	int	      , primary key (conf_ent, conf_seq, conf_idx)
  , conf_id	uuid
  , conf_date	timestamptz	not null default current_timestamp
  , sum		bigint		not null
  , signature	varchar
}

# Generate unique sequence for new tallies
#----------------------------------------------------------------
function mychips.tallies_tf_seq() {mychips.tallies} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.tally_seq is null then
            select into new.tally_seq coalesce(max(tally_seq),0)+1 from mychips.tallies where tally_ent = new.tally_ent;
        end if;
        return new;
    end;
$$;}
trigger mychips_tallies_tr_seq {} {
    before insert on mychips.tallies for each row execute procedure mychips.tallies_tf_seq();
}

# Generate unique sequence for new chit
#----------------------------------------------------------------
function mychips.chits_tf_seq() {mychips.chits} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.chit_idx is null then
            select into new.chit_idx coalesce(max(chit_idx),0)+1 from mychips.chits where chit_ent = new.chit_ent and chit_seq = new.chit_seq;
        end if;
        return new;
    end;
$$;}
trigger mychips_chits_tr_seq {} {
    before insert on mychips.chits for each row execute procedure mychips.chits_tf_seq();
}

# Generate unique sequence for new confirmation
#----------------------------------------------------------------
function mychips.confirms_tf_seq() {mychips.confirms} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.conf_idx is null then
            select into new.conf_idx coalesce(max(conf_idx),0)+1 from mychips.confirms where conf_ent = new.conf_ent and conf_seq = new.conf_seq;
        end if;
        return new;
    end;
$$;}
trigger mychips_confirms_tr_seq {} {
    before insert on mychips.confirms for each row execute procedure mychips.confirms_tf_seq();
}

# Generate notices for front-end listeners
#----------------------------------------------------------------
function mychips.tallies_tf_notice() {mychips.tallies mychips.tallies_v mychips.users_v} {
  returns trigger language plpgsql security definer as $$
    declare
        urec	record;			-- User
        prec	record;			-- Peer
        jrec	jsonb = '{"target": "tally"}';
        act	text;
        channel	text = 'mychips_peer';
    begin
        if (new.request = old.request and new.status = old.status) then
            NULL;
        elsif new.status = 'void' and new.request = 'draft' then
            act = 'userDraft';
        elsif  new.status = 'draft' and new.request = 'void' then
            act = 'userVoid';
        elsif  new.status = 'draft' and new.request = 'open' then
            act = 'userAccept';
        elsif  new.status = 'open' and new.request = 'close' then
            act = 'userClose';
        end if;
        if act is not null then
            select into urec peer_cdi, host_id from mychips.users_v where user_ent = new.tally_ent;
            select into prec peer_cdi, peer_sock from mychips.peers_v where peer_ent = new.partner;
            if not urec.host_id is null then
                channel = channel || '_' || urec.host_id;
            end if;
--            jrec = jsonb_set(jrec, '{guid}', to_jsonb(new.tally_guid));
            jrec = jsonb_set(jrec, '{peer}', to_jsonb(prec.peer_cdi));
            jrec = jsonb_set(jrec, '{user}', to_jsonb(urec.peer_cdi));
            jrec = jsonb_set(jrec, '{entity}', to_jsonb(new.tally_ent));
            jrec = jsonb_set(jrec, '{action}', to_jsonb(act));
            jrec = jsonb_set(jrec, '{at}', to_jsonb(prec.peer_sock));
            jrec = jsonb_set(jrec, '{object}', (select json from mychips.tallies_v where tally_ent = new.tally_ent and tally_guid = new.tally_guid));
            perform pg_notify(channel, jrec::text);
        end if;
        return new;
    end;
$$;}
trigger mychips_tallies_tr_notice {} {
    after update on mychips.tallies for each row execute procedure mychips.tallies_tf_notice();
}

# Base view of tallies
#----------------------------------------------------------------
view mychips.tallies_v {mychips.tallies mychips.users_v} {select 
    eval(fld_list $tallies::tallies_se	te)
  , ue.peer_cdi		as user_cdi
  , ue.peer_sock	as user_sock
  , ue.std_name		as user_name
  , te.user_sig
  , pe.peer_cdi		as part_cdi
  , pe.peer_sock	as part_sock
  , pe.std_name		as part_name
  , te.part_sig
  , case when status = 'void' and request is null		then 'void'
         when status = 'void' and request = 'draft'		then 'userDraft'
         when status = 'draft' and request is null then
           case when user_sig is not null and part_sig is null	then 'userProffer'
                when part_sig is not null and user_sig is null	then 'peerProffer'
           else 'undefined' end
         when status = 'draft' and request = 'void'		then 'userVoid'
         when status = 'draft' and request = 'open'		then 'accepted'
         when status = 'open' and request is null		then 'open'
         when status = 'open' and request = 'close'		then 'userClose'
         when status = 'close' and request is null then
             case when total_c = 0 then 'closed' else'closing' end
         else 'undefined'
     end		as state
   , jsonb_build_object(
       'guid', te.tally_guid,
       'version', te.version,
       'stock', case when te.tally_type = 'stock' then ue.peer_cdi else pe.peer_cdi end,
       'foil',  case when te.tally_type = 'stock' then pe.peer_cdi else ue.peer_cdi end,
       'created', te.tally_date,
       'contract', te.contract,
       'signed', json_build_object(
         'digest', '',
         'stock', case when te.tally_type = 'stock' then te.user_sig else te.part_sig end,
         'foil',  case when te.tally_type = 'stock' then te.part_sig else te.user_sig end
       )
   )								as json

    from	mychips.tallies	te
    join	mychips.users_v	ue on ue.user_ent = te.tally_ent
    join	mychips.users_v	pe on pe.user_ent = te.partner;

--    ev-al(multiview::insert mychips.users_v "
--        {base.ent	{$base::ent_v_in}	{$base::ent_pk}		{$glob::stampup}}
--        {mychips.users	{$users::users_v_in}	{$users::users_pk}}
--    ")
--    ev-al(multiview::update mychips.users_v "
--        {base.ent	{$users::ent_v_up}	{$base::ent_pk}		{$glob::stampup}}
--        {mychips.users	{$users::users_v_up}	{$users::users_pk}	{$glob::stampup}}
--    ")
--    ev-al(multiview::delete mychips.users_v "
--        {mychips.users	{$users::users_pk}	{(old.crt_by = session_user and (current_timestamp - old.crt_date) < '2 hours'::interval) or base.priv_has('userim',3)}}
--    ")
} -grant {
    {mychips	{} {s i u} {d}}
} -primary id

# Process state transitions on tallies
#----------------------------------------------------------------
function {mychips.tally_state(cdi text, obj jsonb, recipe jsonb)} {mychips.tallies_v} {
  returns text language plpgsql as $$
    declare
        curState	text;
        lrec		record;
        entity		int;
        guid		uuid = obj->>'guid';
        tallyType text; notType text; partner int;
    begin
        select into entity peer_ent from mychips.peers where peer_cdi = cdi;
        if not found then return null; end if;

        select into curState state from mychips.tallies_v where tally_ent = entity and tally_guid = guid;
raise notice 'Tally cdi:% entity:% state:% recipe:%', cdi, entity, curState, recipe;
        if not found then
            curState = 'null';			-- Special code for when the tally doesn't exist yet
        end if;
        if not (jsonb_build_array(curState) <@ (recipe->'context')) then	--Not in any applicable state
raise notice 'Z:% C:%', jsonb_build_array(curState), recipe->'context';
            return curState;
        end if;

raise notice 'A';
        if recipe ? 'upsert' then
raise notice '  upsert obj:% curState:%', obj, curState;
          tallyType = (case when obj->>'stock' = cdi then 'stock' else 'foil' end);
          notType = (case when obj->>'stock' = cdi then 'foil' else 'stock' end);
--raise notice '  tallyType:% notType:%', tallyType, notType;
          if curState = 'null' then			-- Need to do insert
            select into partner peer_ent from mychips.peers where peer_cdi = case when tallyType = 'stock' then obj->>'foil' else obj->>'stock' end;
            if not found then return null; end if;
            
            execute 'insert into mychips.tallies (tally_ent,tally_guid,tally_type,tally_date,version,partner,contract,status,comment,user_sig,part_sig,cr_limit,dr_limit) values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13)'
                using entity, guid, tallyType, (obj->>'created')::timestamptz, (obj->>'version')::int, partner, obj->>'contract', 'draft', obj->'comment', obj->'signed'->>tallyType, obj->'signed'->>notType, coalesce((obj->>'crLimit')::bigint,0), coalesce((obj->>'drLimit')::bigint,0);
          else						-- Tally already exists, do update
            execute 'update mychips.tallies set version = $1, contract = $2, status = $3, comment = $4, user_sig = $5, part_sig = $6, cr_limit = $7, dr_limit = $8'
                using (obj->>'version')::int, obj->>'contract', 'draft', obj->'comment', obj->'signed'->>tallyType, obj->'signed'->>notType, coalesce((obj->>'crLimit')::bigint,0), coalesce((obj->>'drLimit')::bigint,0);
          end if;
        end if;

        if recipe ? 'update' then
          for lrec in select * from jsonb_each_text(recipe->'update') loop	--Fixme: should probably restrict which columns can be updated by this method
raise notice '  update set % = %', lrec.key, lrec.value;
            execute 'update mychips.tallies set request = null, ' || lrec.key || ' = $1 where tally_ent = $2 and tally_guid = $3' using lrec.value, entity, guid;
          end loop;
        end if;

        select into curState state from mychips.tallies_v where tally_ent = entity and tally_guid = guid;
        return curState;
    end;
$$;}
