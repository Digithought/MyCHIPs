#Optimized functions for discovering lift pathways
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------

# Discover multiple pathways from one node to another
# Very similar to tallies_v_path but in a functional format to allow specifying bot, top nodes
# Does Depth-first traversal, will return all candidate rows as well as paths that ended before
# completing or finding a cycle.
#----------------------------------------------------------------
define xif {case when %3 isnull then %1.part_%2 else %1.hold_%2 end}
function {mychips.tallies_find_paths(bot_node text, top_node text = '', size int = 0, max_dep int = 10)} {
mychips.users_v mychips.tallies_v_net
} {
 returns table (
   inp text, "out" text
 , edges int, ath text[], uuids uuid[], ents text[], seqs int[], signs text[], min int, max int
 , top text, bot text, circuit boolean, found boolean
 , margin numeric, reward numeric
 , nodes int, bang int
 , fori boolean, foro boolean, segment boolean
 , path text[], at text[], pat text[]
 , top_seq int, top_uuid uuid
 , bot_seq int, bot_uuid uuid
 , top_cid text, top_agent text, top_chad jsonb
 , bot_cid text, bot_agent text, bot_chad jsonb
 , out_cid text, out_agent text, out_chad jsonb
 , inp_cid text, inp_agent text, inp_chad jsonb
   
 ) language sql as $$
  with recursive tally_path (
      inp, out, edges, ath, uuids, ents, seqs, signs, min, margin, max, reward, 
      top, top_tseq, bot, bot_tseq, circuit, found
    ) as (
      select ti.inp, ti.out, 1, array[ti.out], array[ti.uuid], 
             array[ti.tally_ent], array[ti.tally_seq], array[ti.sign],
             ti.min, ti.margin, ti.max, ti.reward, 
             ti.tally_ent, ti.tally_seq, ti.tally_ent, ti.tally_seq, false, false
    from	mychips.tallies_v_net ti
    where	ti.inp = bot_node		-- Path starts here
    and		ti.canlift and coalesce(ti.max,size) >= size
  union all
    select tp.inp					as inp
      , t.out						as out
      , tp.edges + 1					as edges
      , tp.ath || t.out					as ath
      , tp.uuids || t.uuid				as uuids
      , tp.ents || t.tally_ent				as ents
      , tp.seqs || t.tally_seq				as seqs
      , tp.signs || t.sign				as signs
      , least(t.min, tp.min)				as min
      , tp.margin + t.margin * (1 - tp.margin)		as margin	-- Aggregated margin
--      , least(t.max, tp.max)				as max	-- Might charge multiple rewards along segment
      , case when t.min < tp.min then				-- Will charge only one reward in segment
          least(t.max, tp.min)
        else
          least(t.min, tp.max) end			as max
      , case when t.min < tp.min then t.reward
        else tp.reward end				as reward	-- Only one reward
      , t.tally_ent					as top
      , t.tally_seq					as top_tseq
      , tp.bot						as bot
      , tp.bot_tseq					as bot_tseq
      , coalesce(tp.inp = t.out, false)			as circuit
      , t.out = coalesce(top_node,'')			as found

    from	mychips.tallies_v_net t
    join	tally_path	tp on tp.out = t.inp
    		and not t.uuid = any(tp.uuids)
    		and (t.out isnull or not t.out = any(tp.ath))
    where	canlift and coalesce(tp.max, size) >= size
    and		tp.edges < max_dep
    and		not tp.found
  ) select tpr.inp, tpr.out
    , tpr.edges, tpr.ath, tpr.uuids, tpr.ents, tpr.seqs, tpr.signs, tpr.min, tpr.max
    , tpr.top, tpr.bot, tpr.circuit, tpr.found
    , tpr.margin::numeric(8,6)
    , tpr.reward::numeric(8,6)
    , tpr.edges + 1			as nodes
    , tpr.edges * tpr.min		as bang
    , tpr.inp isnull			as fori
    , tpr.out isnull			as foro
    , tpr.inp isnull and tpr.out isnull	as segment
    , tpr.inp || tpr.ath		as path
    , tpr.ath[1:edges-1]		as at
    , tpr.inp || tpr.ath[1:edges-1]	as pat

    , tt.tally_seq as top_tseq, tt.tally_uuid as top_uuid
    , bt.tally_seq as bot_tseq, bt.tally_uuid as bot_uuid

    , tt.hold_cid as top_cid, tt.hold_agent as top_agent, tt.hold_chad as top_chad
    , bt.hold_cid as bot_cid, bt.hold_agent as bot_agent, bt.hold_chad as bot_chad

    , xif(tt,cid,out) as out_cid, xif(tt,agent,out) as out_agent, xif(tt,chad,out) as out_chad
    , xif(bt,cid,inp) as inp_cid, xif(bt,agent,inp) as inp_agent, xif(bt,chad,inp) as inp_chad

  from	tally_path tpr
  join	mychips.tallies_v	tt on tt.tally_ent = tpr.top and tt.tally_seq = tpr.top_tseq
  join	mychips.tallies_v	bt on bt.tally_ent = tpr.bot and bt.tally_seq = tpr.bot_tseq
$$;}

# Discover shortest liftable pathway from bot to top by breadth-first iterative search
#----------------------------------------------------------------
set tab_list {level int bot text bot_seq int top text top_seq int ath text\[\] uuids uuid\[\]}
set tab_pairs [lmap {k v} $tab_list {string cat "$k $v"}]	;#puts "T:$tab_pairs"
set tab_fields [dict keys [dict create {*}$tab_list]]		;#puts "F:$tab_fields"

function {mychips.tallies_find_path(bot_node text, top_node text = '', size int = 0, max_dep int = 10)} {
mychips.users_v mychips.tallies_v_net
} {
 returns table (eval(join $tab_pairs ,)) language plpgsql as $$
  declare
    depth int = 1;
  begin
    drop table if exists queue;	-- Create current/next level table to simulate queue behavior
    create temp table queue (
      id	serial,
      eval(join $tab_pairs ,),
      primary key (level, top, id) include (ath)
    );
    
    insert into queue(level, bot, top, ath, uuids) values (1, bot_node, top_node, '{}'::text[], '{}'::uuid[]);

    while exists (select 1 from queue q where q.level = depth) and depth <= max_dep loop
--raise notice '%: Path: %', depth, (select string_agg(array_to_string(cl.path, ','), ';  ') from levels cl where cl.level = depth);

      if depth > 1 and exists (        -- If the target node is one of the new paths, return the path
        select 1 from queue q where q.level = depth and q.top = top_node
      ) then
        return query select eval(fld_list $tab_fields q)
        from queue q where q.level = depth and q.top = top_node;
        exit;
      end if;

        -- Insert neighbors into the next level if they haven't been visited
      insert into queue (level, bot, bot_seq, top, top_seq, ath, uuids)
        select depth + 1,
          q.bot, coalesce(q.bot_seq, e.tally_seq), 
          e.out, e.tally_seq,
          q.ath || e.out, 
          q.uuids || e.uuid
        from queue q
        join mychips.tallies_v_net e on e.inp = q.top and e.out <> all(q.ath)
        where q.level = depth and coalesce(e.max, size) >= size;

      delete from queue q where q.level = depth;        -- Clean up the current level
      depth := depth + 1;
    end loop;

    drop table if exists queue;		-- Cleanup
  end;
$$;}
