#Schema for chit chain consensus functions
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
#There are three sources for new chits that can potentially result in a trigger firing:
#- Chits sent from the peer via the agent; created/updated in chit_process (stock & foil)
#- Approved by our local user; created/update in chit_process (stock & foil)
#- Chits added/modified as part of this consensus model; chain_process (stock only)
#Since chain_consense is executed in trigger space, we need to take care not to cause
#further triggers (by inserting/updating) chits in that routine.
#TODO:
#- How/where do we detect the consensus error state?
#- Make a query that can find/restart stalled chain activity (call periodically)
#- Call it periodically from the agent scheduler
#- 
module mychips

# Compute current consensus state of this chit
#----------------------------------------------------------------
function {mychips.chit_cstate(ch mychips.chits, ta mychips.tallies)} {mychips.chits} {
  returns text immutable language sql as $$
    select case
      when ch.chain_idx isnull then			'Unlinked'
      when ch.chain_idx <= ta.chain_conf then		'Linked'
      when ch.chain_msg notnull then			'Notify'
      when ch.request = 'good' then			'Linking'
      else						'Pending' end
$$;} -grant mychips

# Attempt to link the current chit into our chain in a way agreeable to our partner
#----------------------------------------------------------------
function {mychips.chain_consense(ch mychips.chits, ta mychips.tallies)} {
  mychips.chits_v
  mychips.chit_json_h(mychips.chits,mychips.tallies)
  mychips.chit_json_r(mychips.chits,mychips.tallies)
  mychips.ba2b64v(bytea)
  mychips.j2h(jsonb)
} {
  returns mychips.chits language plpgsql as $$
    declare
      crec	record;
      msg	jsonb = ch.chain_msg;		-- Remember incoming message
      chain	jsonb = msg->'chain';
      propIdx	int = chain->'index';		-- Suggested chaining index
      propConf	int = chain->'conf';		-- Last confirmed end of chain
      propDgst	bytea = mychips.b64v2ba(chain->>'hash');
--      compDgst	bytea;				-- Locally computed digest
      prevDgst	bytea;				-- Hash from previous chit
      nextIdx	int;				-- Next index in our chain
      ratchet	boolean = false;		-- Roll our confirmation pointer forward
      jrec	jsonb;
      i		int;
    begin
      select into crec * from mychips.chits	-- Find our current end-of-chain chit
        where chit_ent = ch.chit_ent and chit_seq = ch.chit_seq
          and chain_idx notnull order by chain_idx desc limit 1;
raise notice 'Cons T:%-%-% Conf:% Iss:% Units:% eX:% pX:% pD:% M:%', ta.tally_ent,ta.tally_seq,ta.tally_type,ta.chain_conf,ch.issuer,ch.units,crec.chain_idx,propIdx,propDgst,msg;

      if found then				-- Already have a chain
        nextIdx = greatest(crec.chain_idx + 1, 1);
        prevDgst = crec.chain_dgst;
      else					-- No chits in chain yet
        nextIdx = 1;				-- This will be the first
        prevDgst = ta.digest;			-- Begin with hash of the tally
      end if;
      ch.chain_msg = null;			-- Default to no message
--raise notice 'Cons CH: Idx:% nextIdx:% prev:%', ch.chain_idx, nextIdx, prevDgst;

-- Local transition -> good
-- --------------------------------------------------------------
      if msg->>'cmd' = 'loc' then		-- If chit modified by our user
        ch.chain_idx = nextIdx;			-- Link at end of our chain
        ch.chain_prev = prevDgst;
        ch.chain_dgst = mychips.j2h(mychips.chit_json_h(ch, ta));
raise notice 'l C:% d:%', mychips.chit_json_h(ch, ta), ch.chain_dgst;

-- Foil holder gets good chit from stock partner
-- --------------------------------------------------------------
      elsif msg->>'cmd' = 'upd' and ta.tally_type = 'foil' then		-- we choose chit order
        ch.chain_prev = prevDgst;
        ch.chain_idx = nextIdx;
        ch.chain_dgst = mychips.j2h(mychips.chit_json_h(ch, ta));
raise notice 'f C:% d:%', mychips.chit_json_h(ch, ta), ch.chain_dgst;

        if propDgst = ch.chain_dgst and propIdx = ch.chain_idx then	-- stock got it right
raise notice 'Ack with Stock hash:%', ch.chain_dgst;
          ch.chain_msg = jsonb_build_object(
            'cmd',	'ack',
            'index',	ch.chain_idx,
            'hash',	mychips.ba2b64v(ch.chain_dgst)
          );
          ratchet = true;

        else					-- stock's hash doesn't look right
raise notice 'Notify Stock %-%-% hash:%', propConf, propIdx, nextIdx, ch.chain_dgst;
          select into jrec jsonb_agg(json) from (	-- List sequence of chits the stock evidently has wrong
            select json from mychips.chits_v where
              chain_idx between least(propConf+1, ta.chain_conf+1, propIdx) and ch.chain_idx-1
              and chit_ent = ch.chit_ent and chit_seq = ch.chit_seq order by chain_idx
          ) s;
          ch.chain_msg = jsonb_build_object(		-- We are in a trigger handler, update send flag
            'cmd',	'upd',
            'index',	ch.chain_idx,
            'hash',	mychips.ba2b64v(ch.chain_dgst),
            'chits',	jrec || mychips.chit_json_r(ch,ta)	-- Include the present chit
          );
        end if;	-- agree with stock's hash
--        ratchet = true;					-- will mark new end of chain
raise notice 'Cons FOIL: idx:% hash:% prv:% M:%', ch.chain_idx, ch.chain_dgst, ch.chain_prev, ch.chain_msg;

-- Stock holder:
-- --------------------------------------------------------------
      elsif msg->>'cmd' = 'upd' and ta.tally_type = 'stock' then	-- we conform to foil
raise notice 's C:% d:%', mychips.chit_json_h(ch, ta), ch.chain_dgst;

        if propIdx = nextIdx then		-- Incoming chit will fit right at the end
          ch.chain_idx = nextIdx;
          ch.chain_prev = prevDgst;
          ch.chain_dgst = mychips.j2h(mychips.chit_json_h(ch, ta));
raise notice 'At end conf:% idx:% D:% P:%', ta.chain_conf, ch.chain_idx, ch.chain_dgst, ch.chain_prev;

        elsif propIdx < nextIdx and propIdx > ta.chain_conf then	-- Chit overlaps unconfirmed chits
          ch.chain_idx = propIdx;
          if prop_idx = 1 then			-- First link of chain
            ch.chain_prev = ta.digest;
          else					-- Regular non-first link
            select into ch.chain_prev chain_dgst from mychips.chits
              where chit_ent = ch.chit_ent and chit_seq = ch.chit_seq and chain_idx = ch.chain_idx - 1;
raise notice 'Conform conf:% idx:% D:% P:%', ta.chain_conf, ch.chain_idx, ch.chain_dgst, ch.chain_prev;
--raise notice 'P:% F:% Li:% C:% %-%', ch.chain_prev, found, ch.chain_idx-1, ta.chain_conf, ch.chit_ent, ch.chit_seq;
          end if;

          update mychips.chits set		-- Move any chit in our way to end of chain
            chain_idx = nextIdx,
            chain_prev = prevDgst,
            chain_dgst = mychips.j2h(mychips.chit_json_h(mychips.chits, ta)),
            chain_msg = jsonb_build_object(
              'cmd',		'upd',
              'index',	chain_idx,
              'hash',		mychips.ba2b64v(chain_dgst)
            )
            where chit_ent = ch.chit_ent and chit_seq = ch.chit_seq and chit_seq != ch.chit_idx
            and chain_idx = ch.chain_idx;
if found then raise notice 'Bumped:% -> %', ch.chain_idx, nextIdx; end if;
        else					-- No good place to put this chit
          ch.chain_idx = null;
          ch.chain_prev = null;
        end if;
        ch.chain_dgst = mychips.j2h(mychips.chit_json_h(ch, ta));

        if ch.chain_dgst = propDgst then
          ch.chain_msg = jsonb_build_object(	-- Send ack
            'cmd',	'ack',
            'index',	ch.chain_idx,
            'hash',	mychips.ba2b64v(ch.chain_dgst)
          );
          ratchet = true;
        elsif ch.chain_idx isnull then		-- Didn't even try to chain
          ch.chain_msg = jsonb_build_object(	-- Send nak
            'cmd',	'nak',
            'index',	propIdx
          );
        else					-- Tried but hash failed
          ch.chain_msg = jsonb_build_object(	-- Send nak
            'cmd',	'nak',
            'index',	ch.chain_idx,
            'hash',	mychips.ba2b64v(ch.chain_dgst)
          );
        end if;
raise notice 'Cons STOCK: idx:% hash:% prv:% M:%', ch.chain_idx, ch.chain_dgst, ch.chain_prev, ch.chain_msg;
      end if;	-- tally type

      if ratchet then				-- Move chain_conf forward
        update mychips.tallies set chain_conf = propIdx where tally_ent = ch.chit_ent and tally_seq = ch.chit_seq;
      end if;

      if ch.status = 'chain' then
        ch.status = 'good';			-- Restore intended status
      end if;

      return ch;
    end;
$$;}

# Process chit chain messages as requested by the peer server process
#----------------------------------------------------------------
function {mychips.chain_process(msg jsonb, recipe jsonb)} {
  mychips.chits
  mychips.ba2b64v(bytea)
  mychips.b64v2ba(text)
} {
  returns jsonb language plpgsql as $$
    declare
      cid	text	= msg->'to'->>'cid';
      agent	text	= msg->'to'->>'agent';
      obj	jsonb	= msg->'object';
      cmd	text	= obj->>'cmd';
      index	int4;
      didit	boolean = false;
      crec	record;		-- Holds chit record(s)
      trec	record;		-- Holds associated tally
      jrec	jsonb;
      qrec	record;
    begin
--raise notice 'Chainproc cid:% msg:% recipe:%', cid, msg, recipe;
      select into trec tally_ent, tally_seq, tally_type, chain_conf, digest from mychips.tallies_v where hold_cid = cid and tally_uuid = (obj->>'tally')::uuid;
      if not found then return null; end if;
raise notice 'Chainproc T:%-% cid:% conf:% cmd:% R:%', trec.tally_ent, trec.tally_seq, cid, trec.chain_conf, cmd, recipe;

-- Reset message flag ---------------------------------------------
      if recipe::boolean then		-- No chits sent == ACK
        update mychips.chits set chain_msg = null
          where chit_ent = trec.tally_ent and chit_seq = trec.tally_seq and chit_uuid = (obj->>'uuid')::uuid;
        return to_jsonb(found);
      end if;

-- Ack Processor ---------------------------------------------
      if cmd = 'ack' then
        index = obj->>'index';
raise notice 'Ack index:%', index;
        if index = 0 then		-- Special case for tally, block 0
          if mychips.ba2b64v(trec.digest) = (obj->>'hash') then
            update mychips.tallies set chain_conf = index where tally_ent = trec.tally_ent and tally_seq = trec.tally_seq and chain_conf isnull;
          end if;
        else
          select into crec chit_ent, chit_seq, chit_idx, chain_dgst, chain_idx, state from mychips.chits_v
            where chit_ent = trec.tally_ent and chit_seq = trec.tally_seq and chain_idx = index;
          if index > 0 and not found then return null; end if;
--raise notice ' ack C:%-% A:%', crec.chit_ent, crec.chit_seq, index;
          if mychips.ba2b64v(crec.chain_dgst) = (obj->>'hash') and crec.chain_idx = index then
            update mychips.tallies set chain_conf = index where tally_ent = trec.tally_ent and tally_seq = trec.tally_seq;
          end if;
        end if;

-- Upd Processor ---------------------------------------------
      elsif cmd = 'upd' and (obj->>'chits') notnull then
raise notice 'Chain upd:%', obj->'chits';
        for qrec in select * from (	-- Compare chits the foil sent us
            select jsonb_array_elements(obj->'chits') as j
          ) jc left join (        	-- to all we have on stock end
            select * from mychips.chits
              where chit_ent = trec.tally_ent and chit_seq = trec.tally_seq
              and status = 'good' 		-- and chain_idx > trec.chain_conf
          ) c on c.digest = mychips.b64v2ba(jc.j->>'hash')
          order by jc.j->'chain'->'index'
        loop
raise notice '  chain upd:% D:% J:%', qrec.chain_idx, qrec.digest, qrec.j;

          index = (qrec.j->'chain'->'index')::int;

          if qrec.chain_idx = index then	-- We already have this chit OK
raise notice 'OK % %=%', qrec.j->'units', qrec.chain_idx, index;
            continue;
          end if;

--          update mychips.chits set chain_idx = null where chit_ent = trec.tally_ent and chit_seq = trec.tally_seq and chain_idx = index;	-- Bump any provisionally linked chit in our way
          if qrec.chit_ent isnull then		-- We are missing this chit which the foil has
raise notice 'ADD % @:% M:%', qrec.j->'units', index, qrec.j->'chain';
            insert into mychips.chits (
              chit_ent,chit_seq,chit_uuid,chit_date,status,
              signature,issuer,units,reference,memo,chain_msg		-- chain_dgst,chain_idx
            ) values (
              trec.tally_ent, trec.tally_seq, (qrec.j->>'uuid')::uuid,
              (qrec.j->>'date')::timestamptz, 'chain',
              qrec.j->>'signed', (qrec.j->>'by')::tally_side, (qrec.j->>'units')::bigint, 
              qrec.j->'ref', qrec.j->>'memo', qrec.j->'chain'		-- mychips.b64v2ba(qrec.j->'chain'->>'hash'), index
            ) returning * into crec;
            didit = true;

          else		-- Otherwise, we just need to apply the foil's version of the chain index
raise notice 'INDEX % %->% M:%', qrec.j->'units', qrec.chain_idx, index, qrec.j->'chain';
            update mychips.chits set
--              chain_idx = index, chain_dgst = mychips.b64v2ba(qrec.j->'chain'->>'hash'),
              chain_msg = qrec.j->'chain',
              chain_prev = null, status = 'chain'
              where chit_ent = qrec.chit_ent and chit_seq = qrec.chit_seq and chit_idx = qrec.chit_idx
              returning * into crec;
            didit = true;
          end if;
--          ratchet = true;
        end loop;
        if didit then
          for qrec in select * from mychips.chits where status = 'good' and chain_idx isnull loop
raise notice 'Stray: %-%-% %', qrec.chit_ent, qrec.chit_seq, qrec.chit_idx, qrec.units;
          end loop;
        end if;
        
      end if;
      return to_jsonb('OK'::text);
    end;
$$;}

# Notify the peer server process about chit chain messages that need to go out
#----------------------------------------------------------------
function {mychips.chain_notify_agent(ch mychips.chits)} {mychips.chits} {
  returns boolean language plpgsql security definer as $$
    declare
        channel	text	= 'mychips_agent';
        jrec	jsonb;			-- Holds notify record
        trec	record;			-- Talley
    begin
        select into trec tally_uuid,hold_chad,hold_agent,part_chad from mychips.tallies_v where tally_ent = ch.chit_ent and tally_seq = ch.chit_seq;
        if not trec.hold_agent is null then
          channel = 'ma_' || trec.hold_agent;
        end if;

        jrec = jsonb_build_object(
          'target',	'chit',
          'action',	'chain',
          'to',		trec.part_chad,
          'from',	trec.hold_chad,
          'object',	'{"cmd":"upd"}'::jsonb || ch.chain_msg || jsonb_build_object(
            'tally',	trec.tally_uuid,
            'uuid',	ch.chit_uuid
          )
        );
raise notice 'Chain notice:% E:% Cid:% J:%', channel, ch.chit_ent, trec.part_chad->>'cid', jrec;
        perform pg_notify(channel, jrec::text);
        return true;
    end;
$$;}
