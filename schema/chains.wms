#Schema for chit chain consensus functions
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
#There are three sources for new chits that can potentially result in a trigger firing:
#- Chits sent from the peer via the agent; created/updated in chit_process (stock & foil)
#- Approved by our local user; created/update in chit_process (stock & foil)
#- Chits added/modified as part of this consensus model; chain_process (stock only)
#Since chain_consense is executed in trigger space, we need to take care not to cause
#further triggers (by inserting/updating) chits in that routine.
#TODO:
#- How/where do we detect the consensus error state?
#- Make a query that can find/restart stalled chain activity (call periodically)
#- Call it periodically from the agent scheduler
#- 
module mychips

# Compute current consensus state of this chit
#----------------------------------------------------------------
function {mychips.chit_cstate(ch mychips.chits, ta mychips.tallies)} {mychips.chits} {
  returns text immutable language sql as $$
    select case
      when ch.chain_idx isnull then			'Unlinked'
      when ch.chain_idx <= ta.chain_conf then		'Linked'
      when ch.chain_msg notnull then			'Notify'
      when ch.request = 'good' then			'Linking'
      else						'Pending' end
$$;} -grant mychips

# Attempt to link the current chit into our chain in a way agreeable to our partner
#----------------------------------------------------------------
function {mychips.chain_consense(ch mychips.chits, ta mychips.tallies)} {
  mychips.chits_v
  mychips.chit_json_h(mychips.chits,mychips.tallies)
  mychips.chit_json_r(mychips.chits,mychips.tallies)
  mychips.ba2b64v(bytea)
  mychips.j2h(jsonb)
} {
  returns mychips.chits language plpgsql as $$
    declare
      crec	record;
      propIdx	int = ch.chain_msg->'index';	-- Suggested chaining index
      propConf	int = ch.chain_msg->'conf';	-- Last confirmed end of chain
      propDgst	bytea = mychips.b64v2ba(ch.chain_msg->>'hash');
      compDgst	bytea;				-- Locally computed digest
      prevDgst	bytea;				-- Hash from previous chit
      nextIdx	int;				-- Next index in our chain
      ratchet	boolean = false;		-- Roll our confirmation pointer forward
      jrec	jsonb;
      i		int;
    begin
      select into crec * from mychips.chits	-- Find our current end-of-chain chit
        where chit_ent = ch.chit_ent and chit_seq = ch.chit_seq
          and chain_idx notnull order by chain_idx desc limit 1;
raise notice 'Cons T:%-%-% Conf:% Iss:% Units:% eX:% pX:% pD:% rq:% M:%', ta.tally_ent,ta.tally_seq,ta.tally_type,ta.chain_conf,ch.issuer,ch.units,crec.chain_idx,propIdx,propDgst,ch.request,ch.chain_msg;

      if found then				-- Already have a chain
        nextIdx = greatest(crec.chain_idx + 1, 1);
        prevDgst = crec.chain_dgst;
      else					-- No chits in chain yet
        nextIdx = 1;				-- This will be the first
        prevDgst = ta.digest;			-- Begin with hash of the tally
      end if;
      ch.chain_msg = null;			-- Default to no message
--raise notice 'Cons CH: Idx:% nextIdx:% prev:%', ch.chain_idx, nextIdx, prevDgst;

-- Foil holder:
-- --------------------------------------------------------------
      if ta.tally_type = 'foil' then		-- Holding the foil; we are in charge of chit order
        ch.chain_prev = prevDgst;
        ch.chain_idx = nextIdx;
        ch.chain_dgst = mychips.j2h(mychips.chit_json_h(ch, ta));
raise notice 'f H:% d:%', mychips.chit_json_h(ch, ta), compDgst;
        if ch.request isnull then		-- chit received from stock, not our local user

          if propDgst = ch.chain_dgst and propIdx = ch.chain_idx then
raise notice 'Ack with Stock hash:%', ch.chain_dgst;
            ch.chain_msg = jsonb_build_object(	-- if stock computed the index/endhash correctly
              'index',	nextIdx,		-- Queue up an ack
              'hash',	mychips.ba2b64v(ch.chain_dgst)
            );

          else					-- stock's hash doesn't look right
raise notice 'Notify Stock %-%-% hash:%', propConf, propIdx, nextIdx, ch.chain_dgst;
            select into jrec jsonb_agg(json) from (	-- List sequence of chits the stock evidently has wrong
              select json from mychips.chits_v where
                chain_idx between least(propConf, propIdx) and nextIdx
                and chit_ent = ch.chit_ent and chit_seq = ch.chit_seq order by chain_idx
            ) s;
            ch.chain_msg = jsonb_build_object(		-- We are in a trigger handler, update send flag
              'chits',	jrec || mychips.chit_json_r(ch,ta)	-- Include the present chit
            );
          end if;	-- agree with stock's hash
        end if;		-- chit received from stock
        ratchet = true;					-- will mark new end of chain
raise notice 'Cons FOIL: idx:% hash:% prv:% M:%', ch.chain_idx, ch.chain_dgst, ch.chain_prev, ch.chain_msg;

-- Stock holder:
-- --------------------------------------------------------------
      else		-- we hold the stock, must conform to foil
        if ch.chain_idx isnull then		-- Use supplied index
          ch.chain_idx = coalesce(propIdx, nextIdx);	-- or default to our own computed one
        end if;

        ch.chain_prev = prevDgst;		-- Assume chit will link at end of our chain
        compDgst = mychips.j2h(mychips.chit_json_h(ch, ta));	-- Hash would then be this
raise notice 's H:% d:% :%:%', mychips.chit_json_h(ch, ta), compDgst, ch.issuer, ch.request;

        if ch.request notnull then		-- If chit came from our user
          ch.chain_dgst = compDgst;		-- Put it at end of our chain
raise notice 'Provisional chit at X:% Conf:%', ch.chain_idx, ta.chain_conf;

        elsif compDgst = ch.chain_dgst then	-- Does our hash agree with what the foil sent?
raise notice 'Good foil chit conf:% idx:% hash:%', ta.chain_conf, ch.chain_idx, ch.chain_dgst;
          ch.chain_dgst = propDgst;		-- Use proposed digest
          ratchet = true;			-- Will move confirmation pointer forward

        elsif ch.chain_idx = ta.chain_conf + 1 then	-- Chain says this goes next after last confirmed chit
          ch.chain_dgst = propDgst;		-- Use proposed digest
          if ch.chain_idx = 1 then		-- First link of chain
            ch.chain_prev = ta.digest;
          else					-- Regular non-first link
            select into ch.chain_prev chain_dgst from mychips.chits
              where chit_ent = ch.chit_ent and chit_seq = ch.chit_seq and chain_idx = ch.chain_idx - 1;
--raise notice 'P:% F:% Li:% C:% %-%', ch.chain_prev, found, ch.chain_idx-1, ta.chain_conf, ch.chit_ent, ch.chit_seq;
          end if;
raise notice 'Conform chit conf:% idx:% D:% P:%', ta.chain_conf, ch.chain_idx, ch.chain_dgst, ch.chain_prev;
          compDgst = mychips.j2h(mychips.chit_json_h(ch, ta));
          if compDgst != ch.chain_dgst then
            raise exception 'Can''t consense chit: %-%-% %<>%', ch.chit_ent, ch.chit_seq, ch.chit_idx, compDgst, ch.chain_dgst;
--Fixme: should send error packet here
          end if;
--raise notice 'DX:%:%', ch.chain_dgst, compDgst;
          ratchet = true;

        end if;
        update mychips.chits			-- Unchain any chit in our way
          set chain_idx = null -- (select max(chain_idx) from mychips.chits where chit_ent = ch.chit_ent and chit_seq = ch.chit_seq) + 1,
--          request = 'good'
          where chit_ent = ch.chit_ent and chit_seq = ch.chit_seq and chit_seq != ch.chit_idx
          and chain_idx = ch.chain_idx;
if found then raise notice 'Bumped:%', ch.chain_idx; end if;
          
raise notice 'Cons STOCK: idx:% hash:% prv:% M:%', ch.chain_idx, ch.chain_dgst, ch.chain_prev, ch.chain_msg;
      end if;	-- tally type

raise notice 'R:% idx:% hash:% prv:%', ratchet, ch.chain_idx, ch.chain_dgst, ch.chain_prev;
      if ratchet then				-- Move chain_conf forward
        update mychips.tallies set chain_conf = ch.chain_idx where tally_ent = ch.chit_ent and tally_seq = ch.chit_seq;
      end if;

      if ch.status = 'chain' then
        ch.status = 'good';			-- Restore intended status
      end if;

      return ch;
    end;
$$;}

# Process chit chain messages as requested by the peer server process
#----------------------------------------------------------------
function {mychips.chain_process(msg jsonb, recipe jsonb)} {
  mychips.chits
  mychips.ba2b64v(bytea)
  mychips.b64v2ba(text)
} {
  returns text language plpgsql as $$
    declare
      cid	text	= msg->'to'->>'cid';
      agent	text	= msg->'to'->>'agent';
      cmd	text	= msg->>'sub';
      obj	jsonb	= msg->'object';
      index	int4;
      didit	boolean = false;
      crec	record;		-- Holds chit record(s)
      trec	record;		-- Holds associated tally
      jrec	jsonb;
      qrec	record;
    begin
--raise notice 'Chainproc cid:% msg:% recipe:%', cid, msg, recipe;
      select into trec tally_ent, tally_seq, tally_type, chain_conf from mychips.tallies_v where hold_cid = cid and tally_uuid = (obj->>'tally')::uuid;
      if not found then return null; end if;
raise notice 'Chainproc T:%-% cid:% conf:% cmd:% R:%', trec.tally_ent, trec.tally_seq, cid, trec.chain_conf, cmd, recipe;

-- Reset send flag ---------------------------------------------
      if recipe::boolean then		-- No chits sent == ACK
        update mychips.chits set chain_msg = null
          where chit_ent = trec.tally_ent and chit_seq = trec.tally_seq and chit_uuid = (obj->>'uuid')::uuid;

-- Ack Processor ---------------------------------------------
--      if cmd = 'ack' then
      elsif cmd = 'upd' and (obj->>'chits') isnull then		-- No chits sent == ACK
        index = obj->>'index';
raise notice 'index:%', index;
        select into crec chit_ent, chit_seq, chit_idx, chain_dgst, chain_idx, state from mychips.chits_v
          where chit_ent = trec.tally_ent and chit_seq = trec.tally_seq and chain_idx = index;
        if not found then return null; end if;
raise notice 'Chain C:%-% A:%', crec.chit_ent, crec.chit_seq, cmd;
--raise notice 'Chain ack:%-% ix:%-%', crec.chain_dgst, obj->>'chain', crec.chain_idx, index;
        if mychips.ba2b64v(crec.chain_dgst) = (obj->>'hash') and crec.chain_idx = index then
          update mychips.tallies set chain_conf = index where tally_ent = trec.tally_ent and tally_seq = trec.tally_seq;
        end if;

-- Upd Processor ---------------------------------------------
      elsif cmd = 'upd' and (obj->>'chits') notnull then
raise notice 'Chain upd:%', obj->'chits';
        for qrec in select * from (	-- Compare chits the foil sent us
            select jsonb_array_elements(obj->'chits') as j
          ) jc left join (        	-- to all we have on stock end
            select * from mychips.chits
              where chit_ent = trec.tally_ent and chit_seq = trec.tally_seq
              and status = 'good' 		-- and chain_idx > trec.chain_conf
          ) c on c.digest = mychips.b64v2ba(jc.j->>'hash')
          order by jc.j->'chain'->'index'
        loop
raise notice '  chain upd:% D:% J:%', qrec.chain_idx, qrec.digest, qrec.j;

          index = (qrec.j->'chain'->'index')::int;

          if qrec.chain_idx = index then	-- We already have this chit OK
raise notice 'OK % %=%', qrec.j->'units', qrec.chain_idx, index;
            continue;
          end if;

--          update mychips.chits set chain_idx = null where chit_ent = trec.tally_ent and chit_seq = trec.tally_seq and chain_idx = index;	-- Bump any provisionally linked chit in our way
          if qrec.chit_ent isnull then		-- We are missing this chit which the foil has
raise notice 'ADD % @:% M:%', qrec.j->'units', index, qrec.j->'chain';
            insert into mychips.chits (
              chit_ent,chit_seq,chit_uuid,chit_date,status,
              signature,issuer,units,reference,memo,chain_msg		-- chain_dgst,chain_idx
            ) values (
              trec.tally_ent, trec.tally_seq, (qrec.j->>'uuid')::uuid,
              (qrec.j->>'date')::timestamptz, 'chain',
              qrec.j->>'signed', (qrec.j->>'by')::tally_side, (qrec.j->>'units')::bigint, 
              qrec.j->'ref', qrec.j->>'memo', qrec.j->'chain'		-- mychips.b64v2ba(qrec.j->'chain'->>'hash'), index
            ) returning * into crec;
            didit = true;

          else		-- Otherwise, we just need to apply the foil's version of the chain index
raise notice 'INDEX % %->% M:%', qrec.j->'units', qrec.chain_idx, index, qrec.j->'chain';
            update mychips.chits set
--              chain_idx = index, chain_dgst = mychips.b64v2ba(qrec.j->'chain'->>'hash'),
              chain_msg = qrec.j->'chain',
              chain_prev = null, status = 'chain'
              where chit_ent = qrec.chit_ent and chit_seq = qrec.chit_seq and chit_idx = qrec.chit_idx
              returning * into crec;
            didit = true;
          end if;
--          ratchet = true;
        end loop;
        if didit then
          for qrec in select * from mychips.chits where status = 'good' and chain_idx isnull loop
raise notice 'Stray: %-%-% %', qrec.chit_ent, qrec.chit_seq, qrec.chit_idx, qrec.units;
          end loop;
        end if;
        
      end if;
      return 'OK';
    end;
$$;}

# Notify the peer server process about chit chain messages that need to go out
#----------------------------------------------------------------
function {mychips.chain_notify_agent(ch mychips.chits)} {mychips.chits} {
  returns boolean language plpgsql security definer as $$
    declare
        channel	text	= 'mychips_agent';
        jrec	jsonb;			-- Holds notify record
        trec	record;			-- Talley
        sub	text = coalesce(ch.chain_msg->>'sub', 'upd');
    begin
        select into trec tally_uuid,hold_chad,hold_agent,part_chad from mychips.tallies_v where tally_ent = ch.chit_ent and tally_seq = ch.chit_seq;
        if not trec.hold_agent is null then
          channel = 'ma_' || trec.hold_agent;
        end if;

        jrec = jsonb_build_object(
          'target',	'chit',
          'action',	'chain',
          'sub',	sub,
          'to',		trec.part_chad,
          'from',	trec.hold_chad,
          'object',	(ch.chain_msg - 'sub') || jsonb_build_object(
            'tally',	trec.tally_uuid,
            'uuid',	ch.chit_uuid
          )
        );
--raise notice 'Chain notice:% Sub:% E:% Cid:%', channel, sub, ch.chit_ent, trec.part_chad->>'cid';
        perform pg_notify(channel, jrec::text);
        return true;
    end;
$$;}
