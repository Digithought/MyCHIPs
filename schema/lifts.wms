#Schema for tracking the status of distributed lifts
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
#TODO:
#X- Port to protocol 1.0
#X- Can eliminate retry table for lifts?
#X- Schema state transition regression tests
#- Is an integration test feasible now?
#- Get rid of circuit field? (how to remember during init phase whether linear/circuit)
#- 
#- Settable parameters:
#X-   Minimum life left to participate in lift
#-   Max lift life to participate in (ignore lifts with life > L)
#-   Max lift sequence (to detect large/infinite loops)
#- 
#- Implement costed lifts
#-   How do we pick the optimal lift among a variety of available choices?
#-   How/when to compromise on non-zero lift_margins?
#- 
module mychips

namespace eval lifts {
    def lifts_pk	{lift_uuid lift_seq}
    def lifts_v_up	{lift_uuid request find origin referee status signature}
    def lifts_v_in	[concat $lifts_v_up lift_date lift_type tallies units life circuit]
    def lifts_se	[concat $lifts_v_in lift_seq digest]
}

table mychips.lifts {mychips mychips.tallies} {
    lift_uuid	uuid
  , lift_seq	int	      , primary key (lift_uuid, lift_seq)

-- Internal management
  , request	text		constraint "!mychips.lifts.IVR" check(request isnull or request in ('draft','init','seek','call','relay','found','check'))
  , status	text		not null default 'draft' constraint "!mychips.lifts.IVS" check(status in ('draft','init','seek','call','pend','good','void'))
  , tallies	uuid[]		not null
  , lift_type	text		not null default 'rel' constraint "!mychips.lifts.IVT" check(lift_type isnull or lift_type in ('in','org','rel'))
  , circuit	boolean		not null default true

-- Other components of signed tally
  , units	bigint		not null
  , lift_date	timestamptz	not null default current_timestamp
  , life	interval	not null default '2 minutes'
  , find	jsonb
  , origin	jsonb
  , referee	jsonb

  , digest	bytea		
  , signature	text
    eval(s $glob::stamps)
}
#index {} mychips.lifts lift_date

# Generate unique primary key for a new lift
#----------------------------------------------------------------
function mychips.lifts_tf_bi() {mychips.lift_json(mychips.lifts) mychips.j2h(jsonb) mychips.tallies_v} {
  returns trigger language plpgsql security definer as $$
    declare
      trec	record;
    begin
        if new.lift_uuid isnull then
          new.lift_uuid = uuid_generate_v4();	-- Random, agent can change it on init phase
          new.lift_seq = 0;
        elsif new.lift_seq isnull then		-- This is not safe for concurrent insertions
          select into new.lift_seq coalesce(max(lift_seq)+1,0) from mychips.lifts where lift_uuid = new.lift_uuid;
        end if;					-- Will a single lift uuid ever get requests for two new extensions at the same time?  To fix it we will require a separate sequence table (or serialize seq and have possible gaps).

        if new.status = 'draft' and new.request = 'seek' then	-- General consistency check
          if new.life isnull then
            new.life = base.parm('lifts', 'life', '2 minutes'::text)::interval;
          end if;
        end if;

        new.digest = mychips.j2h(mychips.lift_json(new));
        return new;
    end;
$$;}
trigger mychips_lifts_tr_bi {} {
    before insert on mychips.lifts for each row execute procedure mychips.lifts_tf_bi();
}

# After each insert (Lift record has to exist for chits to reference it)
#----------------------------------------------------------------
function mychips.lifts_tf_ai() {mychips.lift_chitcheck(mychips.lifts)} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.request = 'relay' or new.request = 'found'
          or (new.lift_type = 'in' and new.status = 'good') then
            return mychips.lift_chitcheck(new);
        end if;
        return new;
    end;
$$;}
trigger mychips_lifts_tr_ai {} {
    after insert on mychips.lifts for each row execute procedure mychips.lifts_tf_ai();
}

# Before updating each lift record
#----------------------------------------------------------------
function mychips.lifts_tf_bu() {mychips.lift_chitcheck(mychips.lifts) mychips.chits mychips.lift_json(mychips.lifts) mychips.j2h(jsonb)} {
  returns trigger language plpgsql security definer as $$
    declare
      lrec	record;
    begin
      if old.status in ('good','void') then return null; end if;	-- One-way ticket to good,void
      
--      if new.lift_uuid != new.lift_uuid then		-- Referential integrity to attached chits (shouldn't be updating uuid anyway!)
--        update mychips.chits set chit_uuid = new.lift_uuid where chit_type = 'lift' and chit_uuid = old.lift_uuid;
--      end if;						-- Now done with foreign key

--Fixme: what fields will we allow to be updated?
--Fixme: when to update digest?
--      if new.units != old.units or new.socket != old.socket or new.public != old.public then
--        new.digest = mychips.j2h(mychips.lift_json(new));
--      end if;

      if old.status != 'seek' and new.status = 'seek' then
        return mychips.lift_chitcheck(new);
      end if;
--Fixme: OK that we returned (and won't run code below)?

--Fixme: how should we sign lift chits (whether good or failed)?
-- raise notice 'Going to Good:% %', new.lift_uuid, new.lift_seq;
      if old.status != 'good' and new.status = 'good' then
        update mychips.chits set signature = 'Valid', status = 'good' where chit_uuid = new.lift_uuid and lift_seq = new.lift_seq;
      end if;

--Fixme: use 'void'
      if old.status != 'failed' and new.status = 'failed' then
        update mychips.chits set status = 'void' where chit_uuid = new.lift_uuid and lift_seq = new.lift_seq;
      end if;
      return new;
    end;
$$;}
trigger mychips_lifts_tr_bu {} {
    before update on mychips.lifts for each row execute procedure mychips.lifts_tf_bu();
}

# Create pending chits for a specified lift
#----------------------------------------------------------------
function {mychips.lift_chitcheck(lf mychips.lifts)} {mychips.lifts} {
  returns mychips.lifts language plpgsql security definer as $$
    declare
      trec	record;
      uuid	uuid;
      stat	text = case when lf.status = 'good' then 'good' else 'pend' end;
    begin

raise notice 'Chit check:% uuid:% seq:% stat:%', lf.units, lf.lift_uuid, lf.lift_seq, stat;
      foreach uuid in array lf.tallies loop
raise notice '  tally uuid:%', uuid;
        for trec in select * from mychips.tallies where tally_uuid = uuid order by tally_type loop
raise notice '    %-%: % %-%', trec.tally_ent, trec.tally_seq, trec.tally_type, lf.lift_uuid, lf.lift_seq;
          insert into mychips.chits (chit_ent, chit_seq, 
            chit_uuid, lift_seq, chit_type, chit_date, status, units
          ) values (trec.tally_ent, trec.tally_seq, 
            lf.lift_uuid, lf.lift_seq, 'lift', lf.lift_date, stat, -lf.units);
        end loop;
      end loop;
      return lf;
    end;
$$;}

# Notify the peer server process of lift state changes that need attention in the database
#----------------------------------------------------------------
function {mychips.lift_notify(lift mychips.lifts)} {mychips.lifts_v_dist} {
  returns boolean language plpgsql security definer as $$
    declare
        channel		text;
        jrec		jsonb;			-- Holds notify record
        lrec		record;			-- Lift view record
        rrec		record;			-- Retries
    begin
        select into lrec lift_seq, out_chad, top_chad, json, circuit, top_tally, bot_tally,
          find_v, origin_v, referee_v
            from mychips.lifts_v_dist where lift_uuid = lift.lift_uuid and lift_seq = lift.lift_seq;
        channel = 'ma_' || (lrec.top_chad->>'agent');

--raise notice 'Lift object:%', lrec.json;
        jrec = jsonb_build_object('target', 'lift'
          , 'action',	lift.request
          , 'to',	lrec.out_chad
          , 'from',	lrec.top_chad
          , 'top',	lrec.top_tally
          , 'bottom',	lrec.bot_tally
          , 'sequence',	lrec.lift_seq
          , 'object',	lrec.json
        );
        if lift.request = 'init' then		-- Agent needs these to initialize lift
          jrec = jsonb_set(jrec, '{init}', jsonb_build_object(
              'find',		lrec.find_v
            , 'org',		lrec.origin_v
            , 'ref',		lrec.referee_v
            , 'circuit',	lrec.circuit
          ));
        end if;
raise notice 'Lift notice:% %', channel, jrec::text;
        perform pg_notify(channel, jrec::text);
        return true;
    end;
$$;}

# Generate notifications about updated lifts for listening peer servers
#----------------------------------------------------------------
function mychips.lifts_tf_notify() {mychips.lifts} {
  returns trigger language plpgsql security definer as $$
    declare
        dirty	boolean default false;
    begin
        if TG_OP = 'INSERT' and not new.request isnull then
            dirty = true;
        elsif not new.request isnull and new.request is distinct from old.request then
            dirty = true;
        end if;
--raise notice 'Lift update: %: %', dirty, new.request;
        if dirty then perform mychips.lift_notify(new); end if;
        return new;
    end;
$$;}
trigger mychips_lifts_tr_notice {} {
    after insert or update on mychips.lifts for each row execute procedure mychips.lifts_tf_notify();
}

# Compute standard json output for a lift (what gets signed)
#----------------------------------------------------------------
function {mychips.lift_json(lf mychips.lifts)} {mychips.lifts} {
  returns jsonb stable language sql as $$
    select jsonb_build_object(
       'lift',		lf.lift_uuid
     , 'date',		lf.lift_date
     , 'life',		lf.life
     , 'units',		lf.units
     , 'find',		lf.find
     , 'org',		lf.origin
     , 'ref',		lf.referee
    )
$$;}

# Compute current state of a lift
#----------------------------------------------------------------
function {mychips.lift_state(status text, request text)} {mychips} {
  returns text stable language sql as $$
    select
      status ||
      case when request isnull then '' else '.' || request end;
$$;}

# Base view of lifts
#----------------------------------------------------------------
view mychips.lifts_v {mychips.lifts mychips.tallies_v mychips.lift_state(text,text) mychips.lift_json(mychips.lifts) mychips.j2h(jsonb)} {select 
    eval(fld_list $lifts::lifts_se lf)
  , mychips.lift_state(lf.status, lf.request)			as state

  , mychips.lift_json(lf)					as json_core
  , mychips.lift_json(lf) || jsonb_build_object(
      'digest',		lf.digest
    )								as json
  , mychips.j2h(mychips.lift_json(lf))				as digest_v
  , mychips.j2h(mychips.lift_json(lf)) = coalesce(lf.digest,'') as clean
  , lf.lift_date + lf.life					as expires
  , lf.lift_date + lf.life - crt_date				as remains

    from	mychips.lifts	lf

    eval(trigview::insert mychips.lifts_v mychips.lifts $lifts::lifts_v_in $lifts::lifts_pk [concat $glob::stampin]);
    eval(trigview::update mychips.lifts_v mychips.lifts $lifts::lifts_v_up $lifts::lifts_pk $glob::stampup);
} -grant {
    {lift	{s} {i u} {d}}
}

# View of distributed lifts with default values for origin, find, referee
#----------------------------------------------------------------
view mychips.lifts_v_dist {mychips.lifts_v mychips.tallies_v} {select lf.*
  , tt.hold_chad					as top_chad
  , tt.part_chad					as out_chad
  , tt.tally_uuid					as top_tally
  , bt.tally_uuid					as bot_tally
  , coalesce(lf.origin, jsonb_build_object(
      'agent',	bt.hold_agent		-- Or use system agent here?
    , 'host',	bt.hold_host
    , 'port',	bt.hold_port
    , 'from',	jsonb_build_object(
        'cid',		bt.hold_cid
      , 'agent',	bt.hold_agent)
    ))							as origin_v

  , coalesce(lf.find, jsonb_build_object(
      'cid',	bt.part_cid
    , 'agent',	bt.part_agent
    ))							as find_v

  , coalesce(lf.referee, jsonb_build_object(
      'agent',	bt.hold_agent
    , 'host',	bt.hold_host
    , 'port',	bt.hold_port
    ))							as referee_v

    from mychips.lifts_v	lf
    join	mychips.tallies_v	tt on tt.part_ent isnull and
    		tt.tally_uuid = lf.tallies[array_upper(lf.tallies,1)]
    join	mychips.tallies_v	bt on bt.part_ent isnull and
    		bt.tally_uuid = lf.tallies[array_lower(lf.tallies,1)]
}

# Process lift state transitions requested by the peer server process
#----------------------------------------------------------------
function {mychips.lift_process(msg jsonb, recipe jsonb)} {mychips.users_v mychips.lifts_v} {
  returns jsonb language plpgsql as $$
    declare
        obj		jsonb		= msg->'object';		-- Lift JSON record
        seq		int		= msg->'sequence';		-- Lift record specifier
        uuid		uuid		= obj->>'lift';			-- Lift uuid
        units		bigint		= obj->>'units';		-- Lift amount
        to_chad		jsonb		= msg->'to';
        fr_chad		jsonb		= msg->'from';
        find		jsonb		= obj->'find';
        req		text		= 'relay';			-- Default request
        lrec		record;		-- Holds lift record(s)
        qrec		record;		-- Pathway/Route record
        curState	text;		-- Current state
        qstrg		text;		-- Temporary string
        remain		interval;	-- Time remaining on lift
    begin
raise notice 'Lift process uuid:% seq:% recipe:%', uuid, seq, recipe;
      if recipe ? 'query' then			-- If there a query key in the recipe object

        remain = (obj->>'date')::timestamptz + (obj->>'life')::interval - current_timestamp;
--raise notice '  date:% life:% T:%', obj->'date', obj->'life', remain;
        if remain < base.parm('lifts', 'minlife', '1 second'::text)::interval then
          return null;			-- Too late, lift expiring now
        end if;
        
raise notice '  find:% %->% @%', find->>'cid', fr_chad->>'cid', to_chad->>'cid', msg->>'tally';

-- Search for destination in our local tally paths:
        select into qrec uuids,foro from mychips.tallies_v_paths
          where bot_cid = to_chad->>'cid' and bot_agent = to_chad->>'agent'
            and inp_cid = fr_chad->>'cid' and inp_agent = fr_chad->>'agent'
            and bot_uuid = (msg->>'tally')::uuid and fori
            and out_cid = find->>'cid' and out_agent = find->>'agent'
            and min >= units order by edges desc limit 1;
--            and ((top_cid = find->>'cid' and top_agent = find->>'agent' and not foro)
--              or (out_cid = find->>'cid' and out_agent = find->>'agent' and foro))
raise notice 'Search path: %:% found:% for:%', find->>'cid', find->>'agent', found, qrec.foro;

-- Fixme: Create sorter column for this (local min OK, route min OK, local edges longest)
        if not found then		-- Next, try searching upstream routes:
          select into qrec uuids, true as foro from mychips.routes_v_paths
            where bot_cid = to_chad->>'cid' and bot_agent = to_chad->>'agent'
              and inp_cid = fr_chad->>'cid' and inp_agent = fr_chad->>'agent'
              and bot_uuid = (msg->>'tally')::uuid and fori
              and dst_cid = find->>'cid' and dst_agent = find->>'agent'
              and path_min >= units order by route_min desc, edges desc limit 1;
raise notice 'Search route: %:% %', find->>'cid', find->>'agent', found;
          if not found then return null; end if;	-- No viable paths found
        end if;

        if not qrec.foro then req = 'found'; end if;
        insert into mychips.lifts_v (
          request, units, lift_type, lift_uuid, tallies, lift_date, find, origin, referee, life
        ) values (
          req, units, 'rel', uuid, qrec.uuids, (obj->>'date')::timestamptz,
          find, obj->'org', obj->'ref', (obj->>'life')::interval
        ) returning request, state into lrec;
raise notice ' returning: %', lrec.state;
        return to_jsonb(lrec.state);
      end if;		--recipe ? 'query'

      if seq notnull then		-- Explicit lift referenced for update
raise notice ' find by seq:%-%', uuid, seq;
        select into lrec lift_uuid,lift_seq,state from mychips.lifts_v
          where lift_uuid = uuid and lift_seq = seq;
      else				-- Find lift by base tally
raise notice ' find by base tally:%-%', uuid, msg->>'tally';
        select into lrec lift_uuid,lift_seq,state from mychips.lifts_v_dist
          where lift_uuid = uuid and bot_tally = (msg->>'tally')::uuid;
      end if;

      if recipe ? 'update' then
        if found then curState = lrec.state; else curState = 'null'; end if;
raise notice 'Lift state:%', curState;

        if not (jsonb_build_array(curState) <@ (recipe->'context')) then	--Not in any applicable state (listed in our recipe context)
raise notice 'Lift Z:% C:%', jsonb_build_array(curState), recipe->'context';
          return to_jsonb(curState);
        end if;

        qstrg = mychips.state_updater(recipe, 'mychips.lifts_v', 
          '{status, request, origin, referee, find, lift_uuid, signature}', 
          case when recipe->'update' ? 'request' then '{}'::text[] else '{"request = null"}' end
        );
raise notice 'SQL:% % %', qstrg, lrec.lift_uuid, lrec.lift_seq;
        execute qstrg || ' lift_uuid = $1 and lift_seq = $2 
          returning lift_uuid, lift_seq, state' into lrec using lrec.lift_uuid, lrec.lift_seq;
        return to_jsonb(lrec.state);
      end if;		-- recipe ? 'update'

    return null;

--Fixme: are there any notifies needed to the user or do the tally/chit notifies suffice?
--        if lrec.action or (lrec.state = 'peerValid' and (curState is distinct from 'peerValid')) then	-- Also notify if changed to valid state
--raise notice '  lift notify for user channel: mu_%', crec.lift_ent;
--            perform pg_notify('mu_' || crec.lift_ent, crec.json::text);
--        end if;
--        return jsonb_build_object(
--          'state',	lrec.state,
--          'from',	lrec.botu_cid,
--          'user',	lrec.lasp_cid,
--          'return',	lrec.lasp_sock,
--          'signature',	lrec.signature
--        );
    end;
$$;}

# Query the database for possible internal lifts, initiating one or more if needed
#----------------------------------------------------------------
function {mychips.lift_cycle(maxNum int = 1)} {mychips.tallies_v_paths base.parm_v} {
  returns jsonb language plpgsql security definer as $$
    declare
      status	jsonb = '{"done": 0}';
      prec	record;			-- Paths
      orders	text default 'bang desc';
      tstr	text;
      tarr	text[];
      oarr	text[];
      lift_id	uuid;
      min_units	int default base.parm('lifts','minimum',1);		-- Only do lifts of this size or bigger
      ord_by	text default base.parm('lifts','order','bang desc'::text);	-- How to prioritize lifts to perform
      count	int default 0;
      rows	int;
    begin
      if found then		-- Build a custom order-by clause from parm:lifts.order
        foreach tstr in array regexp_split_to_array(prec.value, ',') loop
          oarr = regexp_split_to_array(btrim(tstr), E'\\s+');
--raise notice 'LC1 tstr:% el0:%', tstr, oarr[1];
          tarr = array_append(tarr, quote_ident(oarr[1]) || case when oarr[2] = 'desc' then ' desc' else '' end);
        end loop;
        orders = array_to_string(tarr, ', ');
      end if;

      while count < maxNum loop			-- Search for internal lifts
        tstr = 'select first, length, lift_min, lift_max, lift_margin, path, uuids
                from mychips.tallies_v_paths where circuit and lift_margin <= 0 and 
                lift_min >= $1 order by ' || orders || ' limit 1';
--raise notice 'LC2 min:% max:% ord:% sql:%', min_units, maxNum, orders, tstr;
        execute tstr into prec using min_units;			-- Look for the highest priority lift to execute
        get diagnostics rows = ROW_COUNT;
--raise notice 'LC3 :% % % %', prec.length, prec.lift_min, prec.lift_max, prec.path;
        if rows < 1 then exit; end if;

        insert into mychips.lifts (lift_type,status,route_ent,circuit,path,tallies,units)
          values ('org','good',prec.first,prec.first,prec.path,prec.uuids,prec.lift_min);
          
        count = count + 1;
      end loop;
    return jsonb_set(status, '{done}', count::text::jsonb);
    end;
$$;}

# Attempt a circular distributed lift along the specified segment
#----------------------------------------------------------------
function {mychips.lift_dist(maxNum int = 1)} {mychips.lifts_v mychips.routes_v_paths mychips.users_v} {
  returns int language plpgsql as $$
    declare
      prec	record;
      tstr	text;
      tarr	text[];
      oarr	text[];
      orders	text default 'bang desc';
      min_units	int default base.parm('lifts','minimum',1);		-- Only do lifts of this size or bigger
      ord_by	text default base.parm('lifts','order','bang desc'::text);	-- How to prioritize lifts to perform
      count	int = 0;
      rows	int;
    begin
--raise notice 'LD0:% % %', maxNum, min_units, ord_by;
      foreach tstr in array regexp_split_to_array(ord_by, ',') loop
        oarr = regexp_split_to_array(btrim(tstr), E'\\s+');
--raise notice 'LD1 tstr:% el0:%', tstr, oarr[1];
        tarr = array_append(tarr, quote_ident(oarr[1]) || case when oarr[2] = 'desc' then ' desc' else '' end);
      end loop;
      orders = array_to_string(tarr, ', ');
--raise notice 'LD2 orders:%', orders;

      while count < maxNum loop			-- Search for internal lifts
--        tstr = 'select bot,bot_tseq,top,top_tseq, bot_cid,bot_agent, dst_cid, dst_agent, min
        tstr = 'select uuids, min
          from mychips.routes_v_paths where segment and status = ''good'' and
             min >= $1 order by ' || orders || ' limit 1';
        execute tstr into prec using min_units;		-- Look for the highest priority lift to execute
        get diagnostics rows = ROW_COUNT;
--raise notice 'LD3 rows:% min:% tstr:%', rows, min_units, tstr;
        if rows < 1 then exit; end if;
      
        insert into mychips.lifts (lift_type, circuit, request, units, tallies)
          values ('org', true, 'init', prec.min, prec.uuids);
        count = count + 1;
      end loop;
      return count;
    end;
$$;}

# Attempt a linear distributed lift from a local user to a remote peer
#----------------------------------------------------------------
function {mychips.lift_linear(frm text, tocid text, tohost text, units bigint)} {mychips.lifts_v mychips.routes_v_paths_old mychips.users_v} {
  returns bigint language plpgsql as $$
    declare
      rrec	record;
--      botu_cid	text;
    begin
      select into rrec first,botu_ent,path,uuids,dst_cid,dest_host,lift_min from mychips.routes_v_paths_old where last = frm and dst_cid = tocid and dest_host = tohost and status = 'good' order by lift_margin limit 1;
      if not found then return null; end if;
--      select into botu_cid peer_cid from mychips.users_v where id = rrec.botu_ent;
      
      insert into mychips.lifts (request,route_ent,path,tallies,dst_cid,dest_host,units)
      	values ('init',rrec.first,rrec.path,rrec.uuids,rrec.dst_cid,rrec.dest_host,units);
      return units;
    end;
$$;}
