#Schema for tracking the status of distributed lifts
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
#TODO:
#X- Are upeer_ent,dpeer_ent fields necessary in lift table?
#X- Remove some unused fields in lifts_v (topu_xxx, botu_xxx)
#- Include real site public key and origin port in lift message
#- Generate error if no site public key present (later)
#- 
module mychips

namespace eval lifts {
    def lifts_pk	{lift_guid}
#    def lifts_v_up	{request status signature}
#    def lifts_v_in	[concat lift_guid $lifts_v_up exp_date]
    def lifts_se	[concat lift_guid route_ent circuit path tallies units request status signature socket public dest_chid dest_host req_date exp_date digest]
}

table mychips.lifts {mychips.chits} {
    lift_guid	uuid		primary key
  , request	text		constraint "!mychips.lifts.IVR" check(request isnull or request in ('draft','init','relay','local'))
  , status	text		default 'void' constraint "!mychips.lifts.IVS" check(status in ('init','seek','failed','good','relay','local','pend','void'))

  , route_ent	text		not null constraint "!mychips.lifts.BRE" check (route_ent = path[array_lower(path,1)])
  , dest_chid	text		not null
  , dest_host	text		not null
  , circuit	text		

  , path	text[]		not null
  , tallies	uuid[]		not null
  , socket	text		constraint "!mychips.lifts.BSA" check (not socket isnull or status = 'void')
  , public	text		constraint "!mychips.lifts.BPK" check (not public isnull or status = 'void')
  , units	bigint		not null
  , req_date	timestamptz	not null default current_timestamp
  , exp_date	timestamptz	not null
  , digest	bytea		
  , signature	text
}
#index {} mychips.lifts exp_date

table mychips.lift_tries {mychips.lifts} {
    ltry_guid	uuid	      , primary key (ltry_guid)
  , tries	int		not null default 1
  , last	timestamptz	not null default current_timestamp
}

# Generate unique primary key for a new lift
#----------------------------------------------------------------
function mychips.lifts_tf_bi() {mychips.lift_json(mychips.lifts)} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.lift_guid isnull then
          new.lift_guid = uuid_generate_v5(uuid_generate_v4(), new.dest_chid || '@' || new.dest_host);
        end if;

        if new.exp_date is null then
          new.exp_date = current_timestamp + base.parm('lifts', 'life', '2 minutes'::text)::interval;
        end if;

        new.digest = sha256(mychips.lift_json(new)::text::bytea);
        return new;
    end;
$$;}
trigger mychips_lifts_tr_bi {} {
    before insert on mychips.lifts for each row execute procedure mychips.lifts_tf_bi();
}

# After each insert
#----------------------------------------------------------------
function mychips.lifts_tf_ai() {mychips.lift_chitcheck(mychips.lifts)} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.request = 'relay' or new.request = 'local' then
          return mychips.lift_chitcheck(new);
        end if;
        return new;
    end;
$$;}
trigger mychips_lifts_tr_ai {} {
    after insert on mychips.lifts for each row execute procedure mychips.lifts_tf_ai();
}

# Before updating each lift record
#----------------------------------------------------------------
function mychips.lifts_tf_bu() {mychips.lift_chitcheck(mychips.lifts) mychips.chits mychips.lift_json(mychips.lifts)} {
  returns trigger language plpgsql security definer as $$
    begin
      if new.lift_guid != new.lift_guid then		-- Referential integrity to attached chits (shouldn't be updating guid anyway!)
        update mychips.chits set chit_guid = new.lift_guid where chit_type = 'lift' and chit_guid = old.lift_guid;
      end if;
      if new.units != old.units or new.socket != old.socket or new.public != old.public then
        new.digest = sha256(mychips.lift_json(new)::text::bytea);
      end if;
      if old.request != 'init' and new.request = 'init' then
        return mychips.lift_chitcheck(new);
      end if;
      if old.status != 'good' and new.status = 'good' then
        update mychips.chits set signature = 'Valid', status = 'good' where chit_guid = new.lift_guid;
      end if;
      return new;
    end;
$$;}
trigger mychips_lifts_tr_bu {} {
    before update on mychips.lifts for each row execute procedure mychips.lifts_tf_bu();
}

# Before deleting a lift record
#----------------------------------------------------------------
function mychips.lifts_tf_bd() {mychips.chits} {
  returns trigger language plpgsql security definer as $$
    begin
      delete from mychips.chits where chit_type = 'lift' and chit_guid = old.lift_guid;
      return old;
    end;
$$;}
trigger mychips_lifts_tr_bd {} {
    before delete on mychips.lifts for each row execute procedure mychips.lifts_tf_bd();
}

# Referential integrity from lift chits
#----------------------------------------------------------------
function mychips.lifts_tf_chits() {mychips.chits} {
  returns trigger language plpgsql security definer as $$
    begin
      if new.chit_type = 'lift' and not new.chit_guid isnull
        and not exists (select lift_guid from mychips.lifts where lift_guid = new.chit_guid) then
          return null;
      end if;
      return new;
    end;
$$;}
trigger mychips_lifts_tr_chits {} {
    before insert or update on mychips.chits for each row execute procedure mychips.lifts_tf_chits();
}

# Create pending chits for this lift
#----------------------------------------------------------------
function {mychips.lift_chitcheck(lf mychips.lifts)} {mychips.lifts} {
  returns mychips.lifts language plpgsql security definer as $$
    declare
      trec	record;
      tcount	int;
      guid	uuid;
    begin

      foreach guid in array lf.tallies loop
        tcount = 0;
--raise notice 'Tally units:% guid:%', lf.units, guid;
        for trec in select * from mychips.tallies where tally_guid = guid order by tally_type loop
--raise notice '  tally:% % %', trec.tally_type, trec.tally_ent, trec.tally_seq;
          insert into mychips.chits (chit_ent, chit_seq, chit_guid, chit_type, chit_date, units, status)
            values (trec.tally_ent, trec.tally_seq, lf.lift_guid, 'lift', lf.req_date, -lf.units, 'pend');
        end loop;
        if tcount > 2 then return null; end if;
      end loop;
      return lf;
    end;
$$;}

# Notify the peer server process of lift state changes that need attention in the database
#----------------------------------------------------------------
function {mychips.lift_notify(lift mychips.lifts)} {mychips.lifts_v mychips.lift_tries mychips.users_v} {
  returns boolean language plpgsql security definer as $$
    declare
        act		text	= lift.request;
        channel		text	= 'mychips_peer';
        jrec		jsonb;			-- Holds notify record
        lrec		record;			-- Lift view record
        rrec		record;			-- Retries
    begin
        select into lrec route_cid,route_sock,topu_cid,topu_serv,topu_sock,route_user from mychips.lifts_v where lift_guid = lift.lift_guid;
        if not lrec.topu_serv is null then
            channel = channel || '_' || urec.serv_id;
        end if;

        insert into mychips.lift_tries (ltry_guid) values (lift.lift_guid)
          on conflict (ltry_guid) do update set tries = mychips.lift_tries.tries + 1, last = current_timestamp
            returning * into rrec;
        
        jrec = jsonb_build_object(
          'target',	'lift',
          'action',	act,
          'try',	rrec.tries,
          'last',	rrec.last,
          'user',	lrec.route_cid,
          'at',		lrec.route_sock,
          'from',	lrec.topu_cid,
          'fat',	lrec.topu_sock,
          'local',	lrec.route_user,
          'object',	(select json from mychips.lifts_v where lift_guid = lift.lift_guid)
        );
raise notice 'Lift notice:% %', channel, jrec::text;
        perform pg_notify(channel, jrec::text);
        return true;
    end;
$$;}

# Generate notifications about updated lifts for listening peer servers
#----------------------------------------------------------------
function mychips.lifts_tf_notify() {mychips.lifts} {
  returns trigger language plpgsql security definer as $$
    declare
        dirty	boolean default false;
    begin
        if TG_OP = 'INSERT' and not new.request isnull then
            dirty = true;
        elsif not new.request isnull and new.request is distinct from old.request then
            dirty = true;
        end if;
--raise notice 'Lift update: %: %', dirty, new.request;
        if dirty then perform mychips.lift_notify(new); end if;
        return new;
    end;
$$;}
trigger mychips_lifts_tr_notice {} {
    after insert or update on mychips.lifts for each row execute procedure mychips.lifts_tf_notify();
}

# Compute standard json output for a lift (what gets signed)
#----------------------------------------------------------------
function {mychips.lift_json(lf mychips.lifts)} {mychips.lifts} {
  returns jsonb stable language sql as $$
    select jsonb_build_object(
       'lift',		lf.lift_guid
     , 'target',	lf.dest_chid
     , 'host',		lf.dest_host
     , 'date',		lf.req_date
     , 'expires',	lf.exp_date
     , 'circuit',	lf.circuit
     , 'units',		lf.units
     , 'socket',	lf.socket
     , 'public',	lf.public
    )
$$;}

# Compute current state of a lift
#----------------------------------------------------------------
function {mychips.lift_state(status text, request text, expired boolean)} {mychips} {
  returns text stable language sql as $$
    select
      case when status = 'void' and not request isnull then
        request
      else
        case when status = 'seek' and expired then
          'timeout'
        else status end
      end
$$;}

# Base view of lifts
#----------------------------------------------------------------
view mychips.lifts_v {mychips.lifts mychips.tallies_v mychips.lift_state(text,text,boolean) mychips.lift_json(mychips.lifts)} {select 
    eval(fld_list $lifts::lifts_se	lf)
  , not lf.circuit isnull					as circular
  , mychips.lift_state(lf.status, lf.request
    , current_timestamp > lf.exp_date				-- Expired
  )			as state

  , mychips.lift_json(lf)					as json_core
  , mychips.lift_json(lf) || jsonb_build_object(
      'digest',		lf.digest
    )								as json
  , sha256(mychips.lift_json(lf)::text::bytea) as digest_v
  , sha256(mychips.lift_json(lf)::text::bytea) = coalesce(lf.digest,'') as clean
  
  , re.peer_cid		as route_cid		-- Top of segment peer
  , re.peer_chost	as route_host
--  , re.peer_addr	as route_addr
  , re.peer_sock	as route_sock
--  , re.peer_endp	as route_endp
--  , re.std_name	as route_name
--  , re.serv_id	as route_serv
  , not re.user_ent isnull as route_user

  , te.peer_ent		as topu_ent		-- Top user of local segment
  , te.peer_cid		as topu_cid
  , te.peer_chost	as topu_host
--  , te.peer_addr	as topu_addr
  , te.peer_sock	as topu_sock
--  , te.peer_endp	as topu_endp
--  , te.std_name		as topu_name
  , te.serv_id		as topu_serv

  , be.peer_cid		as botu_cid		-- Bottom user of local segment
--  , be.peer_chost	as botu_host
--  , be.peer_addr	as botu_addr
--  , be.peer_sock	as botu_sock
--  , be.peer_endp	as botu_endp
--  , be.std_name		as botu_name
--  , be.serv_id		as botu_serv

  , le.peer_cid		as lasp_cid		-- Bottom of segment peer
--  , le.peer_chost	as lasp_host
--  , le.peer_addr	as lasp_addr
  , le.peer_sock	as lasp_sock
--  , le.peer_endp	as lasp_endp
--  , le.std_name	as lasp_name
--  , le.serv_id	as lasp_serv

    from	mychips.lifts		lf
    join	mychips.users_v		re on re.peer_ent = lf.route_ent
    join	mychips.users_v		te on te.peer_ent = lf.path[array_lower(lf.path,1)+1]
    join	mychips.users_v		be on be.peer_ent = lf.path[array_upper(lf.path,1)-1]
    join	mychips.users_v		le on le.peer_ent = lf.path[array_upper(lf.path,1)]
    left join	mychips.lift_tries	lt on lt.ltry_guid = lf.lift_guid

--    ev--al(trigview::insert mychips.lifts_v mychips.lifts $lifts::lifts_v_in $lifts::lifts_pk [concat $glob::stampin {request 'userDraft'}]);
--    ev--al(trigview::update mychips.lifts_v mychips.lifts $lifts::lifts_v_up $lifts::lifts_pk $glob::stampup);
} -grant {
    {lift	{s} {i u} {d}}
}

# Process lift state transitions requested by the peer server process
#----------------------------------------------------------------
function {mychips.lift_process(msg jsonb, recipe jsonb)} {mychips.users_v mychips.lifts_v} {
  returns text language plpgsql as $$
    declare
        obj		jsonb		= msg->'object';
        guid		uuid		= obj->>'lift';
        units		bigint		= obj->>'units';
        dchid		text		= obj->>'target';
        dhost		text		= obj->>'host';
        circ		text		= obj->>'circuit';
        ldate		timestamptz	= obj->>'date';
        xdate		timestamptz	= obj->>'expires';
        curState	text;
        qstrg		text;		-- Temporary string
        lrec		record;		-- Holds lift record(s)
        qrec		record;		-- Pathway/Route record
        dest_r		record;		-- Destination entity
        from_r		record;		-- Peer on previous system
        user_r		record;		-- Peer on previous system
        circ_r		record;		-- Circuit completion user
    begin

-- I don't think we need serv_id (unless notifies below get used)
--        select into erec id, serv_id from mychips.users_v where peer_cid = cid;
--        if not found then return null; end if;

        select into dest_r id from mychips.users_v where peer_cid = dchid and peer_chost = dhost and not user_ent isnull;	-- Is the destination a local user?

        select into lrec lift_guid, route_ent, dest_chid, dest_host, state from mychips.lifts_v where lift_guid = guid;
        curState = lrec.state;
--raise notice 'Lift guid:% state:% recipe:%', guid, curState, recipe;
        if not found then
            curState = 'null';		-- Special code for when the specified lift doesn't exist yet
        end if;

        if not (jsonb_build_array(curState) <@ (recipe->'context')) then	--Not in any applicable state (listed in our recipe context)
--raise notice 'Lift Z:% C:%', jsonb_build_array(curState), recipe->'context';
            return curState;
        end if;

        if recipe ? 'query' then		-- If there a query key in the recipe object
--raise notice 'Lift query dest ent:% msg:%', dest_r.id, msg;
          select into from_r id, peer_cid from mychips.users_v where peer_cid = msg->>'from' and peer_sock = msg->>'fat';	-- Look up the base entity
          if not found then return null; end if;

--raise notice 'User search:%@%', msg->>'user', msg->>'at';
          select into user_r id, peer_cid from mychips.users_v where peer_cid = msg->>'user' and peer_sock = msg->>'at';	-- Look up the local user the query is coming via
          if not found then return null; end if;

--Fixme: How/when do I compromise on non-zero lift_margins?

          if dest_r.id isnull then		-- If destination is not locally known

raise notice 'Remote dest: :%@% units:% last:% botu:%', dchid, dhost, units, from_r.id, user_r.id;
-- Attempt to find the next segment for the lift:
            select into qrec route_ent,path,guids from mychips.routes_v_paths
              where dest_chid = dchid and dest_host = dhost
              and last = from_r.id 
              and path[array_upper(path,1)-1] = user_r.id	-- was: botu_ent = user_r.id (wrong)
              and route_lift_min >= units
              order by length desc limit 1;
raise notice 'Relay lift:% path:%', guid, qrec.path;
            if not found then return 'fail'; end if;		-- No upstream paths found

            execute 'insert into mychips.lifts (lift_guid,route_ent,circuit,path,tallies,dest_chid,dest_host,units,socket,public,req_date,exp_date,request) values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,''relay'')'
              using guid, qrec.route_ent, circ, qrec.path, qrec.guids, dchid, dhost, units, obj->>'socket', obj->>'public', ldate, xdate;
            return 'relay';			-- We relayed the lift

          else					-- Destination is a locally known user
raise notice 'Local destination:%', dest_r.id;
-- Attempt to find local segment for the lift:
            if not circ isnull then
              select into circ_r id, peer_cid from mychips.users_v where peer_cid = circ;		-- Look up the user that completes the circuit
              if not found then return null; end if;
            end if;
          
            select into qrec path,guids from mychips.tallies_v_paths
              where first = coalesce(circ_r.id, dest_r.id)	-- complete circuit if specified
              and last = from_r.id and lift_min >= units
              order by length desc limit 1;
            if not found then return 'fail'; end if;		-- No local paths found
            
            execute 'insert into mychips.lifts (lift_guid,route_ent,circuit,path,tallies,dest_chid,dest_host,units,socket,public,req_date,exp_date,request) values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,''local'')'
              using guid, coalesce(circ_r.id,dest_r.id), circ, qrec.path, qrec.guids, dchid, dhost, units, obj->>'socket', obj->>'public', ldate, xdate;
          end if;				-- dest_r.id isnull
          return 'local';
        end if;					-- recipe ? 'query'

        if recipe ? 'update' then			-- There's an update key in the recipe
          qstrg = mychips.state_updater(recipe, 'mychips.lifts', '{status, request, socket, public, signature}', case when recipe->'update' ? 'request' then '{}'::text[] else '{"request = null"}' end);
raise notice 'SQL:%', qstrg;
          execute qstrg || ' lift_guid = $1;' using lrec.lift_guid;
          delete from mychips.lift_tries where ltry_guid = lrec.lift_guid;
        end if;

        select into lrec lift_guid,state,circuit,botu_cid,lasp_sock,signature from mychips.lifts_v where lift_guid = lrec.lift_guid;

--Fixme: are there any notifies to be done here?
--        if lrec.action or (lrec.state = 'peerValid' and (curState is distinct from 'peerValid')) then	-- Also notify if changed to valid state
--raise notice '  lift notify for user channel: mychips_user_%', crec.lift_ent;
--            perform pg_notify('mychips_user_' || crec.lift_ent, crec.json::text);
--            perform pg_notify('mychips_user', crec.json::text);		-- Simulations use this
--        end if;

        return jsonb_build_object(
          'state',	lrec.state,
          'return',	lrec.lasp_sock,
          'signature',	lrec.signature
        )::text;
    end;
$$;}

# Generate a set of chits for a lift involving the specified tallies, all our own users
#----------------------------------------------------------------
function {mychips.internal_lift(units bigint, uupath uuid[])} {mychips.tallies mychips.chits uuid} {
  returns boolean language plpgsql security definer as $$
    declare
      tally_id	uuid;
      lift_id	uuid;
      trec	record;
      tcount	int;
    begin
      lift_id = uuid_generate_v1();
raise notice 'Lift :% %', units, uupath;
      foreach tally_id in array uupath loop
        tcount = 0;
        for trec in select * from mychips.tallies where tally_guid = tally_id order by tally_type loop
          insert into mychips.chits (chit_ent, chit_seq, chit_guid, chit_type, signature, units, status)
            values (trec.tally_ent, trec.tally_seq, lift_id, 'lift', 'Valid', -units, 'good');
          tcount = tcount + 1;
        end loop;
        if tcount != 2 then
          raise exception 'Could not find exactly two tallies for UUID:%', tally_id;
          return false;
        end if;
      end loop;
      return true;
    end;
$$;}

# Query the database for possible internal lifts, initiating one or more if needed
#----------------------------------------------------------------
function {mychips.lift_cycle(maxNum int default 1)} {mychips.tallies_v_paths base.parm_v} {
  returns jsonb language plpgsql security definer as $$
    declare
      status	jsonb = '{"done": 0}';
      prec	record;			-- Paths
      orders	text default 'bang desc';
      tstr	text;
      tarr	text[];
      oarr	text[];
      lift_id	uuid;
      min_units	int default base.parm('lifts','minimum',1);		-- Only do lifts of this size or bigger
      ord_by	text default base.parm('lifts','order','bang desc'::text);	-- How to prioritize lifts to perform
      count	int default 0;
      rows	int;
    begin
      if found then				-- Build a custom order-by clause
        foreach tstr in array regexp_split_to_array(prec.value, ',') loop
          oarr = regexp_split_to_array(btrim(tstr), E'\\s+');
--raise notice 'LC1 tstr:% el0:%', tstr, oarr[1];
          tarr = array_append(tarr, quote_ident(oarr[1]) || case when oarr[2] = 'desc' then ' desc' else '' end);
        end loop;
        orders = array_to_string(tarr, ', ');
      end if;

      while count < maxNum loop			-- Search for internal lifts
        tstr = 'select length, lift_min, lift_max, lift_margin, path, guids from mychips.tallies_v_paths where circuit and lift_margin <= 0 and lift_min >= $1 order by ' || orders || ' limit 1';
raise notice 'LC2 min:% max:% ord:% sql:%', min_units, maxNum, orders, tstr;
        execute tstr into prec using min_units;			-- Look for the highest priority lift to execute
        get diagnostics rows = ROW_COUNT;
raise notice 'LC3 :% % % %', prec.length, prec.lift_min, prec.lift_max, rows;
        if rows < 1 then exit; end if;
        if not mychips.internal_lift(prec.lift_min, prec.guids) then exit; end if;
        count = count + 1;
      end loop;
    return jsonb_set(status, '{done}', count::text::jsonb);
    end;
$$;}

# Attempt a circular lift along the specified segment
#----------------------------------------------------------------
function {mychips.lift_circuit(top text, bot text)} {mychips.lifts_v mychips.routes_v_paths mychips.users_v} {
  returns void language plpgsql as $$
    declare
      rrec	record;
      botu_cid	text;
    begin
      select into rrec first,botu_ent,path,guids,dest_chid,dest_host,lift_min from mychips.routes_v_paths where first = top and dest_ent = bot and circuit and status = 'good' order by lift_margin limit 1;
      if not found then return; end if;
      select into botu_cid peer_cid from mychips.users_v where id = rrec.botu_ent;
      
      insert into mychips.lifts (request,route_ent,circuit,path,tallies,dest_chid,dest_host,units)
      	values ('draft',rrec.first,botu_cid,rrec.path,rrec.guids,rrec.dest_chid,rrec.dest_host,rrec.lift_min);
      
    end;
$$;}
