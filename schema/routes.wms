#Analyze pathways through the network of tallies
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
# Routes indicate a possible lift pathway which exists outside our known set of
# tallies.  We obtain route data by querying adjacent peer servers.
# There are three basic kinds of route records:
# Native: This links two foreign peers, both known to our data set and also
#   linked by an internal pathway found in tallies_v_paths.  This implies it
#   completes a partial circuit (segment) we already know about.
# Relay: This is not for our own benefit but rather a result of a downstream
#   peer having asked us about it.  The route leads from one known foreign peer
#   to an unknown peer, hopefully to be found somewhere upstream.
# Linear: Links a local user to an unknown upstream peer
# 
# 
#TODO:
#- Remove documentation at top of this file in favor of doc/learn-protocol.md
#- Test auto route insertion functions at bottom of file (circuit and linear)
#- Get rid of obsolete fields in mychips.routes and all subordinate objects
#- When a lift completes, mark associated route as good/freshened
#- When a lift fails, mark associated route as bad? (or at least time it out and retry route query)
#- 
#- Old:
#- Should notify the user at end of route_process if a route has just been verified?
#- Test/debug route query retries?  (or should we ignore unanswered queries?)
#- Handle special case where head and tail of segment are the same foreign peer (automatically good)
#- 
#- Only process lifts that have a cost factor 1 or better
#- Allow reverse lifts by examining foil tallies with reverse margins enabled
#- Also honor minimum lift sizes from user settings, or the tallies themselves
#- Raise up any negative costs in the lift to achieve a 1 factor
#- Honor all tally lift variables properly
#-   bal_target
#-   lift_marg
#-   drop_marg
#-   dr_limit
#-   cr_limit
#- Ignore tallies that are not in current status
#- 
#- Show peers that are on different servers reasonably in the path view
#- How to query for off-site lifts?
#- Make indexed, materialized cache of tallies_v_paths that is incrementally updated via triggers
#- 

module mychips
namespace eval routes {
    def routes_pk	{rid}
    def routes_v_up	{status min max margin reward}
    def routes_v_in	[concat $routes_v_up via_ent via_tseq dst_cid dst_agent req_ent req_tseq]
    def routes_se	[concat $routes_pk $routes_v_in step lift_count lift_date good_date]
}

# Stores info about external pathways discovered from foreign servers
#----------------------------------------------------------------
table mychips.routes {mychips.peers mychips.tallies} {
    rid		serial		primary key
  , via_ent	text		not null	-- Owner of local tally that starts the external route
  , via_tseq	int		not null
  ,				foreign key (via_ent, via_tseq) references mychips.tallies on update cascade on delete cascade
  , dst_cid	text		not null
  , dst_agent	text		not null
  , 				constraint "!mychips.routes.UNI" unique (via_ent, via_tseq, dst_cid, dst_agent)
  , req_ent	text
  , req_tseq	int	      , foreign key (req_ent, req_tseq) references mychips.tallies on update cascade on delete cascade

  , status	text		not null default 'draft' constraint "!mychips.routes.BST" check(status in ('draft','pend','good','none'))
  , step	int		not null default 0 check (step >= 0)
  , lift_count	int		not null default 0 check (step >= 0)
  , lift_date	timestamptz	not null default current_timestamp
  , good_date	timestamptz	not null default current_timestamp

  , min		bigint		not null default 0
  , margin	float		not null default 0 constraint "!mychips.paths.LMG" check (margin >= -1 and margin <= 1)
  , max		bigint		not null default 0
  , reward	float		not null default 0 constraint "!mychips.paths.LRW" check (reward >= -1 and reward <= 1)
  
-- Obsolete fields (remove/rename after lifts reworked)
  , route_ent	text		-- not null references mychips.peers on update cascade on delete cascade
  , dest_ent	text		references mychips.users on update cascade on delete cascade
  , dest_chid	text
  , dest_host	text		--?? check ((dest_ent is not null and dest_host isnull) or (dest_ent isnull and dest_host is not null))
  , topu_ent	text		-- not null references mychips.peers on update cascade on delete cascade
  , botu_ent	text		-- not null references mychips.peers on update cascade on delete cascade
  , lift_min	bigint		-- default 0
  , lift_margin	float		-- not null default 0 constraint "!mychips.paths.LMG" check (lift_margin >= -1 and lift_margin <= 1)
  , lift_max	bigint		-- default 0
  , lift_reward	float		-- not null default 0 constraint "!mychips.paths.LRW" check (lift_reward >= -1 and lift_reward <= 1)
  , drop_min	bigint		-- default 0
  , drop_margin	float		-- not null default 0 constraint "!mychips.paths.DMG" check (drop_margin >= -1 and drop_margin <= 1)
  , drop_max	bigint		-- default 0
  , drop_reward	float		-- not null default 0 constraint "!mychips.paths.DRW" check (drop_reward >= -1 and drop_reward <= 1)
--  , primary key(route_ent, dest_chid, dest_host)
}
#index {} mychips.routes used_date

table mychips.route_tries {mychips.routes} {
    rtry_rid	int		primary key references mychips.routes on update cascade on delete cascade
  , tries	int		not null default 1
  , last	timestamptz	not null default current_timestamp
}

# Consistency check for new/updated routes
#----------------------------------------------------------------
function mychips.routes_tf_biu() {mychips.users_v} {
  returns trigger language plpgsql security definer as $$
    begin
        if exists (select id from mychips.users_v where peer_cid = new.dst_cid and peer_agent = new.dst_agent) then
          raise exception '!mychips.routes:CRL';
        end if;
--        if new.dst_cid isnull or new.dst_agent isnull then
--          select into new.dst_cid, new.dst_agent peer_cid, peer_agent from mychips.users_v where user_ent = new.dst_ent;
--        end if;
--        if new.req_ent isnull then
--          new.req_ent = coalesce(new.dst_ent, base.user_id(session_user));
--        end if;

-- These are mostly for simplicity in debugging when manually inserting test routes:
--        if new.topu_ent isnull then new.topu_ent = new.req_ent; end if;
--        if new.botu_ent isnull then new.botu_ent = new.req_ent; end if;
        return new;
    end;
$$;}
trigger mychips_routes_tr_biu {} {
    before insert or update on mychips.routes for each row execute procedure mychips.routes_tf_biu();
}

# Compute current state of a route, based on its various fields
#----------------------------------------------------------------
function {mychips.route_state(status text, expired boolean)} {mychips} {
  returns text stable language plpgsql as $$
    begin return
      status ||
      case when status in ('pend','open') and expired then '.X' else '' end;
    end;
$$;}

# Cache route lifetime interval
#----------------------------------------------------------------
function {mychips.route_life()} {mychips base.parm_v} {
  returns interval language plpgsql stable as $$
    begin
      return base.parm('routes', 'life', '1 week'::text)::interval;
    end;
$$;}

# Base view of pathway routes
#----------------------------------------------------------------
view mychips.routes_v {mychips.routes mychips.users_v mychips.peers_v mychips.tallies_v mychips.route_state(text,boolean) base.parm_v mychips.route_life()} {select 
    eval(fld_list $routes::routes_se	ro)
  , it.hold_cid		as via_cid
  , it.hold_agent	as via_agent
  , it.hold_chad	as via_chad
  , it.tally_uuid	as via_tally

  , it.part_cid		as route_cid		-- Route via this partner peer
  , it.part_agent	as route_agent
  , it.part_chad	as route_chad

  , ro.req_tseq isnull	or qt.part_ent is not null as native	-- native: route request generated on this site
  , qt.tally_uuid	as req_tally
  , qt.hold_cid		as req_cid		-- Our user/owner of downstream request tally
  , qt.hold_agent	as req_agent
  , qt.hold_chad	as req_chad
  , qt.part_cid		as rept_cid		-- Foreign partner request came through
  , qt.part_agent	as rept_agent
  , qt.part_chad	as rept_chad

  , greatest(ro.good_date,ro.lift_date) + mychips.route_life()	as expires
  , rt.tries		as tries
  , rt.last		as last
  , mychips.route_state(ro.status
    , current_timestamp > greatest(ro.good_date, ro.lift_date) + mychips.route_life()	-- Expired
  )			as state
  , jsonb_build_object(				-- For upstream query packet
       'step',		ro.step
     , 'tally',		it.tally_uuid
     , 'find' ,	jsonb_build_object(
         'cid', 	ro.dst_cid
       , 'agent',	ro.dst_agent
       )
    )			as json
--  , jsonb_build_object(				-- For downstream response packet
--       'tally',		qt.tally_uuid
--     , 'lading' , jsonb_build_object(
--          'lmin'   , 	rp.lift_min, 	'lmax'   , 	rp.lift_max
--        , 'lmargin',	rp.lift_margin, 'lreward',	rp.lift_reward
--        , 'dmin'   , 	rp.drop_min, 	'dmax'   , 	rp.drop_max
--        , 'dmargin',	rp.drop_margin, 'dreward',	rp.drop_reward
--       )
--    )			as reverse

    from	mychips.routes		ro
    join	mychips.users_v		ie on ie.user_ent = ro.via_ent
    join	mychips.tallies_v	it on it.tally_ent = ro.via_ent and it.tally_seq = ro.via_tseq
    left join	mychips.tallies_v	qt on qt.tally_ent = ro.req_ent and qt.tally_seq = ro.req_tseq
    left join	mychips.route_tries	rt on rt.rtry_rid = ro.rid
--    left join	mychips.routes_v_paths	rp on rp.first = ro.route_ent and rp.dst_chid = ro.dst_chid and rp.dst_host = ro.dst_host and rp.last = ro.req_ent and ro.status = 'good';

    eval(trigview::insert mychips.routes_v mychips.routes $routes::routes_v_in $routes::routes_pk);
    eval(trigview::update mychips.routes_v mychips.routes $routes::routes_v_up $routes::routes_pk);
}

# Notify the peer server process of route state changes, and next state request, that needs attention in the database
#----------------------------------------------------------------
function {mychips.route_notify(route mychips.routes)} {mychips.routes_v mychips.route_tries} {
  returns void language plpgsql security definer as $$
    declare
        jrec	jsonb;
        orec	record;			-- Route
        prec	record;			-- Route/path
        rrec	record;			-- Retries
        channel	text = 'mychips_agent';
    begin
        if route.status = 'pend' then			-- pend: no notification needed
          return;				
        end if;

--Fixme: How are retries supposed to work (especially on good/none)?
        insert into mychips.route_tries (rtry_rid) values (route.rid)
          on conflict (rtry_rid) do update set tries = mychips.route_tries.tries + 1, last = current_timestamp
            returning * into rrec;

        jrec = jsonb_build_object('target', 'route'
          , 'action'	, route.status
          , 'try'	, rrec.tries
          , 'last'	, rrec.last
        );

raise notice 'Rd:% %:%', route.status, route.dst_cid, route.dst_agent;
        select into orec via_chad,via_agent,route_chad,native,json,  min,max,margin,reward
          from mychips.routes_v where rid = route.rid;

        if route.status = 'draft' then			-- draft: request upstream query
          if not orec.via_agent isnull then channel = 'ma_' || orec.via_agent; end if;
          jrec = jrec || jsonb_build_object(
              'to'	, orec.route_chad
            , 'from'	, orec.via_chad
            , 'object'	, orec.json
          );

        elsif route.status in ('good','none') then	-- good,none: notify someone
raise notice 'Rs:% % %', route.rid, route.req_ent, route.req_tseq;

          if (orec.native) then			-- Notify requesting user
            jrec = jsonb_build_object('target','route'
              , 'action',	route.status
              , 'object', jsonb_build_object('route',	route.rid
                , 'find',	jsonb_build_object('cid', route.dst_cid, 'agent', route.dst_agent)
                , 'lading',	jsonb_build_object('min',orec.min,'max',orec.max,'margin',orec.margin,'reward',orec.reward)
              )
            );
            perform pg_notify('mu_' || route.req_ent, jrec::text);
            return;

          else					-- Notify downstream site
            select into prec req_ent,req_tally,req_agent,rept_cid,rept_agent,rept_chad,req_chad,		--Find the path/route anchored at the requester
              jsonb_build_object('min',min,'max',max,'margin',margin,'reward',reward) as lading
            from mychips.routes_v_paths
              where rid = route.rid and bot = req_ent and bot_tseq = req_tseq
              order by margin, min desc, max desc limit 1;		--Reporting only on the cheapest, biggest lading
raise notice 'Rz:% % % %', prec.req_ent,prec.rept_cid, prec.rept_agent, prec.lading;

            channel = 'ma_' || prec.req_agent;
            jrec = jrec || jsonb_build_object(
                'to'	, prec.rept_chad
              , 'from'	, prec.req_chad
              , 'object', jsonb_build_object(
                  'tally', prec.req_tally
                , 'lading', prec.lading
              )
            );
          end if;	-- If native
        end if;		-- good, none

raise notice 'Route notice:% %', channel, jrec::text;
        perform pg_notify(channel, jrec::text);			-- Notify peer server of next state action request
    end;
$$;}

# Generate notifications about updated routes for listening peer servers
#----------------------------------------------------------------
function mychips.routes_tf_notify() {mychips.route_notify(mychips.routes)} {
  returns trigger language plpgsql security definer as $$
    declare
        dirty	boolean default false;
    begin
        if TG_OP = 'INSERT' then
            dirty = true;
        elsif new.status != old.status then
            dirty = true;
        end if;
        if dirty then perform mychips.route_notify(new); end if;
        return new;
    end;
$$;}
trigger mychips_routes_tr_notice {} {
    after insert or update on mychips.routes for each row execute procedure mychips.routes_tf_notify();
}

# Process route state transitions requested by the peer server process
#----------------------------------------------------------------
function {mychips.route_process(msg jsonb, recipe jsonb)} {mychips.routes_v mychips.users_v mychips.tallies_v} {
  returns text language plpgsql as $$
    declare
        to_chad		jsonb = msg->'to';
        fr_chad		jsonb = msg->'from';
        obj		jsonb = msg->'object';
        find		jsonb = obj->'find';
        currStep	int = coalesce((obj->'step')::int, 0);
        dest		record;		-- Searching for this user (may exist on our system)
        route		record;		-- Holds route record(s)
        base		record;		-- Tally the query came in on
        path		record;		-- Found local path record
        qstrg		text;		-- Temporary string
        trec		record;		-- Temporary record
        xrec		record;		-- Temporary record
        curState	text;
        havePath	boolean default false;
        stopSearch	boolean default false;
        fwdCnt		int default 0;	-- Count how many queries forwarded
    begin
raise notice 'Route process msg: %; recipe: %', msg, recipe;

        select into base tally_ent, tally_seq, tally_uuid, hold_cid, hold_agent, part_cid, part_agent from mychips.tallies_v where
--            part_cid = fr_chad->>'cid' and part_agent = fr_chad->>'agent' and
--            hold_cid = to_chad->>'cid' and hold_agent = to_chad->>'agent' and
            tally_uuid = (obj->>'tally')::uuid and liftable;
        if not found then return null; end if;		-- Can we find the tally this came in on
raise notice ' tally: % % %', base.tally_ent, base.tally_seq, base.tally_uuid;

        select into dest id, peer_cid, peer_chost from mychips.users_v where peer_cid = find->>'cid' and peer_agent = find->>'agent';	-- Do we have the destination entity locally?

raise notice '  dest local: % %', dest.id, obj->>'find';
        if recipe->'query' then			-- If there a query flag in the recipe object

          if base.part_cid != fr_chad->>'cid' or base.part_agent != fr_chad->>'agent' or
             base.hold_cid != to_chad->>'cid' or base.hold_agent != to_chad->>'agent' then
               return null;		-- Query message to/from must match our known tally
          end if;			-- Verifies query is coming from downstream on this tally

          if not dest.id isnull then			-- If destination is a local user
            select into path inp,out,min,max,margin,reward from mychips.tallies_v_paths		-- Do we have a path to him?
              where inp = base.tally_ent and top = dest.id order by margin, min desc limit 1;
            if found then havePath = true; end if;	-- We have at least one pathway
            
            if not exists (select bot from mychips.tallies_v_paths
              where inp = base.tally_ent and foro and not dest.id = any(ath)) then
                stopSearch = true;
            end if;	-- Might there be other possible external pathways to destination from here?
          end if;	-- destination is local user
          
          if not stopSearch and currStep <= base.parm('routes', 'maxstep', 12) then	-- Keep looking for routes?

            for trec in select top,tseq from mychips.tallies_v_paths	-- Find all upstream paths we might query further
              where inp = base.tally_ent and foro limit base.parm('routes', 'maxquery', 100) loop

              select into xrec rid,status,state,expires from mychips.routes_v where via_ent = trec.top and via_seq = trec.tseq		-- Does a route already exist?
                and dst_cid = find->>'cid' and dst_agent = find->>'agent';
              if found then						-- Found existing route
                if xrec.expires < current_timestamp then		-- But its expired
                  update mychips.routes set status = 'draft', step = currStep + 1;
                  fwdCnt = fwdCnt + 1;
                elsif status = 'good' then	-- Count existing good routes as part of the fan-out
                  fwdCnt = fwdCnt + 1;
                end if;
                    
              else
                insert into mychips.routes (via_ent, dst_cid, dst_agent, req_ent, req_tseq, step)
                  values (trec.top, find->>'cid', find->>'agent', currStep + 1);
                fwdCnt = fwdCnt + 1;
              end if;
              if fwdCnt <  base.parm('routes', 'maxforward', 12) then exit; end if;
            end loop;
          end if;	-- still looking for routes

          if havePath then
            return 'affirm|' || jsonb_build_object(
              'min',	path.min,	'max',		path.max,
              'margin',	path.margin,	'reward',	path.reward
            )::text;

--Fixme: are these return values even used?
          elsif fwdCnt > 0 then
            return 'relay';			-- We relayed the query
          else
            return 'fail';			-- No upstream paths found
          end if;
        end if;		-- recipe->'query'

        if recipe ? 'update' then
          select into route * from mychips.routes_v where via_cid = to_chad->>'cid' and via_tally = (obj->>'tally')::uuid;
          curstate = coalesce(route.state,'null');		-- If the route doesn't exist yet

raise notice ' state:% recipe:%', curState, recipe;
          if not (jsonb_build_array(curState) <@ (recipe->'context')) then	--Not in any applicable state (listed in our recipe context)
raise notice 'RZ:% C:%', jsonb_build_array(curState), recipe->'context';
            return curState;
          end if;

          if not route.rid isnull then
            qstrg = mychips.state_updater(recipe, 'mychips.routes_v', '{status, min, margin, max, reward}', '{"good_date = current_timestamp"}');
raise notice 'SQL:%', qstrg;
            execute qstrg || 'rid = $1 returning rid, state' into route using route.rid;
            if recipe->'update'->>'status' in ('good','none') then	-- Resolution found, delete retry counter
              delete from mychips.route_tries where rtry_rid = route.rid;
            end if;
          end if;
          return route.state;
        end if;		-- recipe ? 'update'
      return null;
    end;
$$;}

# Check to see if it is time to retry this route check
#----------------------------------------------------------------
function {mychips.route_retry(new mychips.routes)} {mychips.routes} {
  returns boolean language plpgsql as $$
    begin
--raise notice 'Route Retry: % %', new.route_ent, new.dest_ent;
--Fixme: How/when do we decide to mark an old record to retry?
    return false;
    end;
$$;}

# Check for possible new circular routes associated with a specified entity
#----------------------------------------------------------------
function {mychips.route_circuit(entity text)} {mychips.routes mychips.tallies_v_paths_old} {
  returns void language plpgsql as $$
    declare
      trec	record;
    begin
      for trec in select first,last,path from mychips.tallies_v_paths_old where length >= 3 and entity = any(path) and segment loop
raise notice 'Route Circuit check: % % %', entity, trec.first, trec.last;
        insert into mychips.routes (route_ent, dest_ent, topu_ent, botu_ent, req_ent) 
          values (trec.first, trec.last, trec.path[2], trec.path[array_upper(trec.path,1)-1], entity)
            on conflict (route_ent, dest_chid, dest_host)
              do update set status = 'draft' where mychips.route_retry(excluded);
      end loop;
    end;
$$;}

# Check for possible new linear routes from an entity to a specified destination peer
#----------------------------------------------------------------
function {mychips.route_linear(entity text, cid text, agent text)} {mychips.routes mychips.tallies_v_paths} {
  returns void language plpgsql as $$
    declare
      trec	record;
      locid	text;
    begin
      select into locid id from mychips.users where peer_cid = cid and peer_agent = agent;	-- Is destination a user on our system?
--Fixme: does this work?      
      for trec in select inp,out,path from mychips.tallies_v_paths where length > 2 and out = entity and inp is distinct from locid and fori loop
raise notice 'Route Linear check: % % %', entity, peer, trec.inp;
-- xxxxxx
--        insert into mychips.routes (route_ent, dest_chid, dest_host, topu_ent, botu_ent, req_ent) 
--          values (trec.first, peer, host, trec.path[2], entity, entity)
--            on conflict (route_ent, dest_chid, dest_host)
--              do update set status = 'draft' where mychips.route_retry(excluded);
      end loop;
    end;
$$;}
