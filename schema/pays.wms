# Indirect payments to and from other users
#Copyright MyCHIPs.org; See license in root of this package
#----------------------------------------------------------------
#TODO:
#- 
require common.tcl glob.tcl ../trigview.tcl
module mychips

namespace eval pays {
    def pays_pk		{pay_ent pay_seq}
    def pays_v_up	{units memo reference}
    def pays_v_in	[concat $pays_pk $pays_v_up]
    def pays_se		[concat $pays_v_in $glob::stampfn]
}

# Record of a user's distributed payments
#----------------------------------------------------------------
table mychips.pays {mychips.users base.ent mychips.lifts} {
    pay_ent	text		references base.ent on update cascade on delete cascade
  , pay_seq	int	      , primary key (pay_ent, pay_seq)
  , pay_disb	boolean		not null default true

-- Payment details
  , pay_date	timestamptz(3)	not null default current_timestamp
  , party	jsonb		not null
  , units	bigint		not null constraint "!mychips.pays:PUN" check(units >= 0)
  , reference	jsonb
  , memo	text
  , signature	text		constraint "!mychips.pays:GDS" check(signature notnull or (pay_disb and lift_uuid notnull))

-- Internal management
--  , request	text		constraint "!mychips.pays:BRQ" check(request in ('seek','pend'))
--  , status	text		not null default 'draft' constraint "!mychips.pays:BST" check(status in ('draft','seek','pend','good'))
  , lift_uuid	uuid	      , foreign key (lift_uuid, lift_seq) references mychips.lifts on update cascade on delete cascade
  , lift_seq	int		not null default 0

    eval(s $glob::stamps)
}

# Generate unique sequence number for new payments
#----------------------------------------------------------------
function mychips.pays_tf_seq() {mychips.users base.curr_eid()} {
  returns trigger language plpgsql security definer as $$
    begin
      if new.pay_ent isnull then
         new.pay_ent = base.curr_eid();
      end if;
      if new.pay_seq is null then
        update mychips.users set _last_pay = greatest(
            coalesce(_last_pay, 0) + 1,
            (select coalesce(max(pay_seq),0)+1 from mychips.pays where pay_ent = new.pay_ent)
          ) where user_ent = new.pay_ent
            returning _last_pay into new.pay_seq;
        if not found then new.pay_seq = 1; end if;
-- select into new.pay_seq coalesce(max(pay_seq),0)+1 from mychips.pays where pay_ent = new.pay_ent; -- Not safe for concurrent sessions
      end if;
    end;
$$;}
trigger mychips_pays_tr_seq {} {
    before insert on mychips.pays for each row execute procedure mychips.pays_tf_seq();
}

#Basic view
#----------------------------------------------------------------
view mychips.pays_v {mychips.pays mychips.users_v mychips.lifts_v} {select
    eval(fld_list $pays::pays_se p)
  , u.peer_cid, u.peer_agent, u.std_name
  , case when p.pay_disb then -p.units else p.units end as net
  , l.state
  
  , jsonb_strip_nulls(jsonb_build_object(
       'date',	p.pay_date
     , 'part',	p.party
     , 'units', p.units
     , 'ref',	p.reference
     , 'memo',	p.memo
    )) as "json_core"
  , '{}'::jsonb as json
      
    from	mychips.pays		p
    join	mychips.users_v		u	on u.user_ent = p.pay_ent
    left join	mychips.lifts_v		l	on l.lift_uuid = p.lift_uuid and l.lift_seq = p.lift_seq

    eval(trigview::insert mychips.pays_v mychips.pays $pays::pays_v_in $pays::pays_pk [concat $glob::stampin]);
    eval(trigview::update mychips.pays_v mychips.pays $pays::pays_v_up $pays::pays_pk $glob::stampup);
}

# User-permissioned view
#----------------------------------------------------------------
view mychips.pays_v_me {mychips.pays_v base.curr_eid()} {select 
    p.*
    from	mychips.pays_v	p
    where	p.pay_ent = base.curr_eid()
} -grant {
    {pays	{s} {s i u} {d}}
}
