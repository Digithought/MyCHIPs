<!DOCTYPE html>
<!--
TODO:
- Build fat arrow for lift
X-  Make input box with each slider
X-  Get them to display along bottom
X-  Can input number into boxes
X-  or adjust current number with sliders
-  Build tap, responsive to slider
-  Make arrow reusable
- Bidirectional arrow for regular chits
- Make target, bound display at different vertical height
- 
- Review css styles
- 
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Trading Variable Settings</title>
  <style>
    html, body {
/*      padding: 0; */
/*      margin: 0; */
      font-family: sans-serif;
      font-size: 18px;
      text-anchor: left;
    }

    #svgContainer {
      width: 100%;
      position: relative;
    }
    #reportSVG {
/*      border: 1px blue solid; */
      width: 100%;
      display: block;
      margin: 0 auto;
    }
    #reportTitle {
/*      position: absolute;*/
      top: 10px;
      left: 10px;
    }
    #ranges {
/*      width: 100%; */
      display: flex;
      justify-content: space-between;
    }
    .rangeArea {
        width: 49%;
    }
    .rangeRow {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      height: 1.5em;
    }
    .rangeArea input[type=number] {
      width: 10ch;
    }
    .rangeArea .slider {
      width: 100%;
    }
    .setpoint {
      font-size: 12px;
    }
    
  </style>
</head>
<body>
  <div id="svgContainer">
    <p id="reportTitle">Trading Variable Settings</p>
    <svg id="reportSVG">
      <defs>
        <marker id="arrow" stroke="inherit" fill="inherit" orient="auto-start-reverse" markerUnits="userSpaceOnUse"/>
        <radialGradient id="radGrad">
          <stop offset="0%" style="stop-color:#FFF; stop-opacity:0.9"/>
          <stop offset="100%" style="stop-color:#ccc; stop-opacity:0"/>
        </radialGradient>
      </defs>
    </svg>
  </div>

  <div id="ranges">
    <div class="rangeArea">
      <div class="rangeRow">
        <p>Reward:</p>
          <input type="number" id="rewardBox" value="0" min="-1" max="1" step="0.01"/>
      </div>
      <input type="range" class="slider" id="rewardRange" value="0" min="-1" max="1" step="0.01"/>
    </div>
    <div class="rangeArea">
      <div class="rangeRow">
        <p>Clutch:</p>
          <input type="number" id="clutchBox" value="0" min="-1" max="1" step="0.01"/>
      </div>
      <input type="range" class="slider" id="clutchRange" value="0" min="-1" max="1" step="0.01"/>
    </div>
</div>

<!---
<script src="d3.js" charset="utf-8" type="text/javascript"></script>
--->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.3.0/d3.js" charset="utf-8" type="text/javascript"></script>

<script>
const markerWidth	= 12			//Link arrowhead marker
const markerHeight	= 8
const arrowPoints	= [[0, 0], [0, markerHeight], [markerWidth, markerHeight/2]]	//Path to sketch arrowhead
//const Pi2		= Math.PI / 2
var svgWid = 400, svgHei = 160		//Default image size
var border		= 10
var graphX		= svgWid * 0.80
var graphY		= svgHei * 0.80
var entRad		= 5
var entWidth		= 40
var entHeight		= svgHei * 0.80
var arrWidth		= 20

var entityData = [
  {name: 'Me', x:0, y:20},
  {name: 'Partner', x:graphX, y:20}
]
var setPointData = [
  {name: 'Target', x:10, y:0},
  {name: 'Bound', x:30, y:0}
]
var liftArrowData = [
  {name: 'Lift', x:0, y:60, tap:0, yOut: 60, fill:'yellow'},
  {name: 'Drop', x:0, y:100, tap:0, yOut: 20, fill:'orange'}
]

const svg = d3.select("#reportSVG")			//Basic SVG settings
    .attr("viewBox", [-border, -border, svgWid + border * 2, svgHei + border * 2])
//    .attr("width", svgWid).attr("height", svgHei)
.call(s=>s.append("g").append("path").attr("stroke","#8F8").attr("fill","none").attr("d",`M0,0 V${svgHei} H${svgWid} v${-svgHei} h${-svgWid}`))	//Outline for debug
    
svg.select('#arrow')			//Add attributes to arrow marker
  .attr('viewBox', [0, 0, markerWidth, markerHeight])
  .attr('refX', 0).attr('refY', markerHeight/2)
  .attr('markerWidth', markerWidth).attr('markerHeight', markerHeight)
  .append('path').attr('d', d3.line()(arrowPoints))

const entities = svg.selectAll(".entity")
  .data(entityData)
  .join('g').attr("class", "entity")
  .attr("transform", d => `translate(${d.x},${d.y})`)
  .call(s => {
    s.append("rect")
      .attr("x", 0).attr("y", 0)
      .attr("rx", entRad)
      .attr("width", entWidth).attr("height", entHeight)
      .attr("stroke", "blue").attr("stroke-width", 1)
      .attr("fill", "lightblue")
  })

const paintArrows = function () {
  svg.selectAll(".liftArrow")
  .data(liftArrowData)
  .join('g').attr("class", "liftArrow")
  .attr("transform", d => `translate(${d.x},${d.y})`)

  .selectAll("path")
  .data(d => [d])
  .join("path")
    .attr("d", d => {
      let alen = graphX
        , xTap = alen / 4
        , tapRad = arrWidth / 2
        , tapSize = Math.abs(arrWidth * d.tap)
        , bigArc = tapRad + tapSize
        , dir = d.tap >= 0 ? -1 : 1
        , a1 = d.tap >= 0
             ? `a ${tapRad} ${tapRad} 0 0 0 ${-tapRad} ${tapRad}`
             : `a ${bigArc} ${bigArc} 0 0 1 ${bigArc} ${bigArc}`
        , a2 = d.tap >= 0
             ? `a ${bigArc} ${bigArc} 0 0 1 ${bigArc} ${-bigArc}`
             : `a ${tapRad} ${tapRad} 0 0 0 ${-tapRad} ${-tapRad}`
      return `M 0 0 L 0 ${-arrWidth / 2} H ${alen}
          v ${d.tap >= 0 ? arrWidth : arrWidth - tapSize}
          h ${d.tap >= 0 ? -xTap + tapRad : -xTap - tapRad}
          ${a1}
          v ${d.yOut} h ${-tapSize} v${-d.yOut}
          ${a2}
          H 0 Z`
    })
    .attr("stroke-width", 1)
    .attr("stroke", "grey").attr("fill", d => d.fill)
}

const dragSets = d3.drag()		//Drag function called by set points
  .on("start", function (ev, d) {
      d3.select(this).raise().classed("active", true);
  })
  .on("drag", function (ev, d) {	//console.log("drag:", ev, d)
    d.x = ev.x
    d3.select(this)
      .attr("transform", `translate(${d.x},${d.y})`)
//    paintSets()
  })
  .on("end", function (ev, d) {
    d3.select(this).classed("active", false);
  })

const setPoints = svg.selectAll(".setpoint")
  .data(setPointData)
  .join('g').attr("class", "setpoint")
  .attr("transform", d => `translate(${d.x},${d.y})`)
  .call(s => {
    s.append("line")
      .attr("x1", 0).attr("y1", 20)
      .attr("x2", 0).attr("y2", graphY)
      .attr("stroke", "blue").attr("stroke-width", 1)
  })
  .call(s => {
    s.append("text")
      .attr("x", 0).attr("y", 15)
      .text(d => d.name)
  })
  .call(dragSets)

function repaint() {
console.log("Repaint:")
//  bodyGen = new VisBSUser(userData)
//  let user = bodyGen.user(userData)
  
//  egoRad = user.radius
//  ego.html(user.body)			//;console.log("UserBody:", user.body)
  
//  paintEgo()
}

repaint()

document.getElementById("rewardRange").oninput = function() {
  document.getElementById("rewardBox").value = this.value;
  liftArrowData[0].tap = this.value
  paintArrows()
}
document.getElementById("rewardBox").oninput = function() {
  document.getElementById("rewardRange").value = this.value;
  liftArrowData[0].tap = this.value
  paintArrows()
}
document.getElementById("clutchRange").oninput = function() {
  document.getElementById("clutchBox").value = this.value;
  liftArrowData[1].tap = this.value
  paintArrows()
}
document.getElementById("clutchBox").oninput = function() {
  document.getElementById("clutchRange").value = this.value;
  liftArrowData[1].tap = this.value
  paintArrows()
}

//repaint() {
//  paintArrows()
//}

paintArrows()

</script>
</body>
</html>
